# fum_frontend_nblm

Generated on: 2025-08-26 06:58:24

<?xml version="1.0" ?>
<fum_frontend_nblm>
  <metadata>
    <global_stats>
      <total_files>55</total_files>
      <total_size_bytes>244462</total_size_bytes>
      <total_loc>6739</total_loc>
    </global_stats>
    <chunk_stats>
      <files_in_chunk>55</files_in_chunk>
      <size_in_chunk_bytes>244462</size_in_chunk_bytes>
      <loc_in_chunk>6739</loc_in_chunk>
    </chunk_stats>
  </metadata>
  <ascii_map><![CDATA[
frontend/
├── DEV_PLANS.md
│   (LOC: 0, Size: 0 B)
├── README.md
│   (LOC: 0, Size: 0 B)
├── __init__.py
│   (LOC: 18, Size: 779 B)
├── __main__.py
│   (LOC: 21, Size: 484 B)
├── app.py
│   (LOC: 194, Size: 8.6 KB)
├── callbacks/
│   ├── charts.py
│   │   (LOC: 43, Size: 1.7 KB)
│   ├── chat.py
│   │   (LOC: 117, Size: 4.1 KB)
│   ├── engram.py
│   │   (LOC: 72, Size: 2.6 KB)
│   ├── feed.py
│   │   (LOC: 62, Size: 2.3 KB)
│   ├── file_picker/
│   │   ├── __init__.py
│   │   │   (LOC: 20, Size: 497 B)
│   │   ├── common.py
│   │   │   (LOC: 414, Size: 16.3 KB)
│   │   └── registrars.py
│   │       (LOC: 188, Size: 6.7 KB)
│   ├── interval.py
│   │   (LOC: 37, Size: 1.1 KB)
│   ├── logs.py
│   │   (LOC: 72, Size: 2.5 KB)
│   ├── perf.py
│   │   (LOC: 91, Size: 2.7 KB)
│   ├── process.py
│   │   (LOC: 316, Size: 9.3 KB)
│   ├── profile.py
│   │   (LOC: 223, Size: 7.9 KB)
│   ├── runtime.py
│   │   (LOC: 131, Size: 4.1 KB)
│   └── workspace.py
│       (LOC: 62, Size: 2.0 KB)
├── components/
│   ├── charts.py
│   │   (LOC: 18, Size: 443 B)
│   ├── chat.py
│   │   (LOC: 62, Size: 2.1 KB)
│   ├── feed.py
│   │   (LOC: 40, Size: 1.3 KB)
│   ├── layout.py
│   │   (LOC: 71, Size: 2.5 KB)
│   ├── perf.py
│   │   (LOC: 95, Size: 3.4 KB)
│   ├── run_config/
│   │   ├── __init__.py
│   │   │   (LOC: 61, Size: 1.5 KB)
│   │   └── sections.py
│   │       (LOC: 212, Size: 8.8 KB)
│   ├── run_config.py
│   │   (LOC: 42, Size: 1.3 KB)
│   ├── runtime_controls.py
│   │   (LOC: 220, Size: 7.9 KB)
│   ├── widgets/
│   │   ├── file_breadcrumbs.py
│   │   │   (LOC: 51, Size: 1.8 KB)
│   │   ├── file_picker.py
│   │   │   (LOC: 236, Size: 10.0 KB)
│   │   ├── file_tree.py
│   │   │   (LOC: 86, Size: 3.0 KB)
│   │   └── graph.py
│   │       (LOC: 11, Size: 317 B)
│   └── workspace.py
│       (LOC: 72, Size: 2.3 KB)
├── controllers/
│   ├── __init__.py
│   │   (LOC: 17, Size: 352 B)
│   ├── charts_controller.py
│   │   (LOC: 289, Size: 11.1 KB)
│   ├── chat_controller.py
│   │   (LOC: 119, Size: 3.6 KB)
│   ├── file_picker_controller.py
│   │   (LOC: 147, Size: 4.9 KB)
│   ├── file_picker_ctx.py
│   │   (LOC: 30, Size: 867 B)
│   ├── file_picker_status.py
│   │   (LOC: 83, Size: 2.6 KB)
│   └── runtime_controller.py
│       (LOC: 156, Size: 5.6 KB)
├── debug_ui.py
│   (LOC: 429, Size: 17.1 KB)
├── models/
│   └── series.py
│       (LOC: 170, Size: 5.3 KB)
├── plugins/
│   ├── fum_reporting_v1/
│   └── fum_visualizer_v1/
│       └── fum_visualizer.py
│           (LOC: 535, Size: 19.9 KB)
├── services/
│   ├── process_manager.py
│   │   (LOC: 308, Size: 12.4 KB)
│   └── status_client.py
│       (LOC: 87, Size: 2.9 KB)
├── styles/
│   ├── README.md
│   │   (LOC: 128, Size: 4.8 KB)
│   ├── __init__.py
│   │   (LOC: 64, Size: 1.8 KB)
│   ├── base.py
│   │   (LOC: 59, Size: 2.5 KB)
│   ├── components.py
│   │   (LOC: 57, Size: 1.7 KB)
│   ├── layout.py
│   │   (LOC: 101, Size: 2.6 KB)
│   └── theme.py
│       (LOC: 53, Size: 1.6 KB)
├── utilities/
│   ├── fs_utils.py
│   │   (LOC: 98, Size: 3.1 KB)
│   ├── pdf_utils.py
│   │   (LOC: 145, Size: 4.2 KB)
│   ├── profiles.py
│   │   (LOC: 142, Size: 4.9 KB)
│   └── tail.py
│       (LOC: 164, Size: 4.7 KB)
├── view_models/
└── views/]]></ascii_map>
  <files>
    <file>
      <path>DEV_PLANS.md</path>
      <content/>
    </file>
    <file>
      <path>README.md</path>
      <content/>
    </file>
    <file>
      <path>__init__.py</path>
      <content><![CDATA["""
FUM Runtime Frontend (modularized)

Modules:
- fs_utils: filesystem helpers (runs listing, JSON IO) — re-exported from utilities.fs_utils
- tail: tailing JSONL with byte offsets — re-exported from utilities.tail
- series: streaming metrics buffers and helpers — re-exported from models.series
- process_manager: launch/stop runtime process from the UI — re-exported from services.process_manager
- app: Dash app entrypoint (build_app, main)
"""

# Re-export modules at package root for stable imports: fum_rt.frontend.fs_utils, etc.
from .utilities import fs_utils as fs_utils
from .utilities import tail as tail
from .models import series as series
from .services import process_manager as process_manager

__all__ = ["fs_utils", "tail", "series", "process_manager"]]]></content>
    </file>
    <file>
      <path>__main__.py</path>
      <content><![CDATA[from __future__ import annotations

import os

from .app import build_app


def main() -> None:
    rr = os.getenv("RUNS_ROOT", "").strip() or os.path.abspath("runs")
    app = build_app(rr)
    host = os.getenv("DASH_HOST", "127.0.0.1")
    try:
        port = int(os.getenv("DASH_PORT", "8050"))
    except Exception:
        port = 8050
    # Avoid debug reloader to prevent duplicate callbacks
    app.run(host=host, port=port, debug=False)


if __name__ == "__main__":
    main()]]></content>
    </file>
    <file>
      <path>app.py</path>
      <content><![CDATA["""
Copyright © 2025 Justin K. Lietz, Neuroca, Inc. All Rights Reserved.

This research is protected under a dual-license to foster open academic
research while ensuring commercial applications are aligned with the project's ethical principles. Commercial use requires written permission from Justin K. Lietz.
See LICENSE file for full terms.
"""

from __future__ import annotations

import os
import dash
from typing import List, Dict, Any

from dash import Dash, dcc, html

from fum_rt.frontend.utilities.fs_utils import list_runs, _list_files
from fum_rt.frontend.services.process_manager import ProcessManager
from fum_rt.frontend.utilities.profiles import get_default_profile
from fum_rt.frontend.styles import get_global_css

from fum_rt.frontend.components.workspace import workspace_card
from fum_rt.frontend.components.runtime_controls import runtime_controls_card
from fum_rt.frontend.components.feed import feed_card
from fum_rt.frontend.components.run_config import run_config_card
from fum_rt.frontend.components.charts import charts_card
from fum_rt.frontend.components.chat import chat_card
from fum_rt.frontend.components.perf import perf_card

from fum_rt.frontend.callbacks.workspace import register_workspace_callbacks
from fum_rt.frontend.callbacks.charts import register_chart_callbacks
from fum_rt.frontend.callbacks.runtime import register_runtime_callbacks
from fum_rt.frontend.callbacks.process import register_process_callbacks
from fum_rt.frontend.callbacks.feed import register_feed_callbacks
from fum_rt.frontend.callbacks.profile import register_profile_callbacks
from fum_rt.frontend.callbacks.logs import register_logs_callbacks
from fum_rt.frontend.callbacks.chat import register_chat_callbacks
from fum_rt.frontend.callbacks.engram import register_engram_callbacks
from fum_rt.frontend.callbacks.perf import register_perf_callbacks
from fum_rt.frontend.callbacks.interval import register_interval_callbacks
from fum_rt.frontend.callbacks.file_picker.registrars import (
    register_file_picker_static,
    register_file_picker_engram,
)


def build_app(runs_root: str) -> Dash:
    """
    Factory for the FUVDM Live Dashboard Dash app.
    - Assembles layout (cards/components)
    - Installs modular callbacks
    - Keeps ProcessManager scoped to the app instance
    """
    # UI throttling and safe startup:
    # - prevent_initial_callbacks avoids callback storms at load
    # - suppress_callback_exceptions allows lazy mounting of tabs/sections
    app = Dash(
        __name__,
        prevent_initial_callbacks=True,
        suppress_callback_exceptions=True,
    )
    app.title = "FUM Live Dashboard"

    # Global theme
    GLOBAL_CSS = get_global_css()
    app.index_string = app.index_string.replace("</head>", f"<style>{GLOBAL_CSS}</style></head>")

    # Workspace context
    runs = list_runs(runs_root)
    default_run = runs[0] if runs else ""

    # Paths (compute repository root from this file so structure works regardless of CWD)
    repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
    PROFILES_DIR = os.path.join(repo_root, "run_profiles")
    os.makedirs(PROFILES_DIR, exist_ok=True)

    # Services
    manager = ProcessManager(runs_root)
    default_profile = get_default_profile()

    # Profile discovery for initial options
    def list_profiles() -> List[str]:
        try:
            return sorted([os.path.join(PROFILES_DIR, f) for f in os.listdir(PROFILES_DIR) if f.endswith(".json")])
        except Exception:
            return []

    # Static dropdowns
    domain_options = [
        {"label": n, "value": n}
        for n in [
            "math_physics",
            "quantum",
            "standard_model",
            "dark_matter",
            "biology_consciousness",
            "cosmogenesis",
            "higgs",
        ]
    ]
    profile_options = [{"label": os.path.basename(p), "value": p} for p in list_profiles()]
    # Data feed files — bound and non-recursive to avoid heavy startup scans
    try:
        DATA_SCAN_MAX = int(os.getenv("DASH_DATA_SCAN_MAX", "300"))
    except Exception:
        DATA_SCAN_MAX = 300
    DATA_EXTS = [".txt", ".jsonl", ".json", ".csv", ".pdf"]
    data_dir = os.path.join(repo_root, "fum_rt", "data")
    os.makedirs(data_dir, exist_ok=True)
    paths = _list_files(data_dir, exts=DATA_EXTS, recursive=False)[: max(0, DATA_SCAN_MAX)]
    data_files_options = [{"label": p, "value": p} for p in paths]

    # Layout
    app.layout = html.Div(
        [
            html.H3("FUVDM Live Dashboard (experimental control)"),
            html.Div(
                [
                    # Left panel
                    html.Div(
                        [
                            workspace_card(runs_root, runs, default_run),
                            runtime_controls_card(default_profile),
                            perf_card(),
                            feed_card(data_files_options),
                        ],
                        style={"minWidth": "320px", "display": "grid", "gap": "16px"},
                    ),
                    # Right panel
                    html.Div(
                        [
                            run_config_card(default_profile, domain_options, profile_options),
                            charts_card(),
                            chat_card(),
                        ],
                        style={"minWidth": "400px", "display": "grid", "gap": "16px"},
                    ),
                ],
                className="grid",
            ),
            # Global UI poll — environment-tunable and disable-able
            # DASH_POLL_MS: >0 interval in ms (default 1200); <=0 disables polling
            dcc.Interval(
                id="poll",
                interval=max(250, int(os.getenv("DASH_POLL_MS", "1200")) if os.getenv("DASH_POLL_MS", "").strip() != "" else 1200),
                n_intervals=0,
                disabled=(int(os.getenv("DASH_POLL_MS", "1200")) if os.getenv("DASH_POLL_MS", "").strip() != "" else 1200) <= 0,
            ),
            dcc.Store(id="chat-state"),
            dcc.Store(id="ui-state"),
        ],
        style={"padding": "10px"},
    )

    # Callbacks (modular)
    # Diagnostic: print Dash/version and callback registration progress
    try:
        print(f"[dash] version={dash.__version__}")
    except Exception:
        pass

    register_workspace_callbacks(app, runs_root, manager)
    print(f"[callbacks] workspace registered; total={len(getattr(app, 'callback_map', {}))}")
    register_chart_callbacks(app)
    print(f"[callbacks] charts registered; total={len(getattr(app, 'callback_map', {}))}")
    register_runtime_callbacks(app, default_profile)
    print(f"[callbacks] runtime registered; total={len(getattr(app, 'callback_map', {}))}")
    register_feed_callbacks(app, manager, repo_root)
    print(f"[callbacks] feed registered; total={len(getattr(app, 'callback_map', {}))}")
    register_process_callbacks(app, runs_root, manager, default_profile)
    print(f"[callbacks] process registered; total={len(getattr(app, 'callback_map', {}))}")
    register_profile_callbacks(app, PROFILES_DIR, default_profile)
    print(f"[callbacks] profile registered; total={len(getattr(app, 'callback_map', {}))}")
    register_logs_callbacks(app, manager)
    print(f"[callbacks] logs registered; total={len(getattr(app, 'callback_map', {}))}")
    register_chat_callbacks(app)
    print(f"[callbacks] chat registered; total={len(getattr(app, 'callback_map', {}))}")
    register_engram_callbacks(app)
    print(f"[callbacks] engram registered; total={len(getattr(app, 'callback_map', {}))}")
    register_perf_callbacks(app)
    print(f"[callbacks] perf registered; total={len(getattr(app, 'callback_map', {}))}")
    register_interval_callbacks(app)
    print(f"[callbacks] interval registered; total={len(getattr(app, 'callback_map', {}))}")

    # File Picker integrations (bounded IO, no recursive scans):
    register_file_picker_static(app, prefix="feed-file", root=data_dir, exts=DATA_EXTS, target_id="feed-path")
    print(f"[callbacks] filepicker feed registered; total={len(getattr(app, 'callback_map', {}))}")
    register_file_picker_static(app, prefix="profile-file", root=PROFILES_DIR, exts=[".json"], target_id="profile-path")
    print(f"[callbacks] filepicker profile registered; total={len(getattr(app, 'callback_map', {}))}")
    register_file_picker_engram(app, prefix="engram-file", exts=[".h5", ".npz"], target_id="rc-load-engram-path", fallback_root=runs_root)
    print(f"[callbacks] filepicker engram registered; total={len(getattr(app, 'callback_map', {}))}")

    print(f"[callbacks] registration complete; total={len(getattr(app, 'callback_map', {}))}")
    return app]]></content>
    </file>
    <file>
      <path>callbacks/charts.py</path>
      <content><![CDATA[from __future__ import annotations

import plotly.graph_objs as go
from dash import Input, Output  # noqa: F401 (Dash binds these at runtime)
from fum_rt.frontend.controllers.charts_controller import compute_dashboard_figures
from fum_rt.frontend.models.series import SeriesState  # for type awareness in compute


def register_chart_callbacks(app):
    """
    Register figure update callbacks on the provided Dash app.
    Delegates business logic to controllers.compute_dashboard_figures
    so it can be reused outside Dash (e.g., batch exporters).
    """

    @app.callback(
        Output("fig-dashboard", "figure"),
        Output("fig-discovery", "figure"),
        Input("poll", "n_intervals"),
        Input("run-dir", "value"),
        Input("proc-status", "children"),
        Input("ui-state", "data"),
        prevent_initial_call=False,
    )
    def update_figs(_n, run_dir, proc_status, ui_state):
        if not run_dir:
            return go.Figure(), go.Figure()

        # Clear once when process (re)starts or resumes (avoid perpetual resets).
        try:
            last_ps = getattr(update_figs, "_last_proc_status", None)
            if isinstance(proc_status, str) and proc_status != last_ps:
                if ("Resumed." in proc_status) or ("Started." in proc_status):
                    setattr(update_figs, "_state", None)
            setattr(update_figs, "_last_proc_status", proc_status)
        except Exception:
            pass

        state = getattr(update_figs, "_state", None)
        ui = ui_state or {}
        fig1, fig2, new_state = compute_dashboard_figures(run_dir, state, ui)
        setattr(update_figs, "_state", new_state)
        return fig1, fig2]]></content>
    </file>
    <file>
      <path>callbacks/chat.py</path>
      <content><![CDATA[from __future__ import annotations

import os
import json
from dash import Input, Output, State, no_update  # noqa: F401

from fum_rt.frontend.utilities.tail import tail_jsonl_bytes
from fum_rt.frontend.controllers.chat_controller import (
    items_from_utd_records,
    items_from_inbox_records,
    trim_items,
    render_chat_view,
)


def register_chat_callbacks(app):
    """
    Chat callbacks:
      - on_chat_send: append user text to chat_inbox.jsonl in the selected run
      - on_chat_update: stream UTD macro 'say' events + user inbox into a simple text view

    State shape stored in dcc.Store(id="chat-state"):
      {
        "run_dir": str,
        "utd_size": int,     # last read byte offset for utd_events.jsonl
        "inbox_size": int,   # last read byte offset for chat_inbox.jsonl
        "items": List[Dict]  # standardized chat items
      }
    """

    @app.callback(
        Output("chat-status", "children"),
        Output("chat-input", "value"),
        Input("chat-send", "n_clicks"),
        State("run-dir", "value"),
        State("chat-input", "value"),
        prevent_initial_call=True,
    )
    def on_chat_send(_n, run_dir, text):
        rd = (run_dir or "").strip()
        msg = (text or "").strip()
        if not rd:
            return "Select a run directory.", no_update
        if not msg:
            return "Type a message.", no_update
        try:
            inbox = os.path.join(rd, "chat_inbox.jsonl")
            os.makedirs(os.path.dirname(inbox), exist_ok=True)
            with open(inbox, "a", encoding="utf-8") as fh:
                fh.write(json.dumps({"type": "text", "msg": msg}, ensure_ascii=False) + "\n")
            return "Sent.", ""
        except Exception as e:
            return f"Error writing chat_inbox.jsonl: {e}", no_update

    @app.callback(
        Output("chat-view", "children"),
        Output("chat-state", "data"),
        Input("poll", "n_intervals"),
        Input("chat-filter", "value"),
        Input("ui-state", "data"),
        State("run-dir", "value"),
        State("chat-state", "data"),
        prevent_initial_call=False,
    )
    def on_chat_update(_n, filt, ui_state, run_dir, data):
        rd = (run_dir or "").strip()
        if not rd:
            return "", {"run_dir": "", "utd_size": 0, "inbox_size": 0, "items": []}

        state = data or {}
        items = list(state.get("items", []))
        last_run = state.get("run_dir")
        utd_size = int(state.get("utd_size", 0)) if isinstance(state.get("utd_size"), int) else 0
        inbox_size = int(state.get("inbox_size", 0)) if isinstance(state.get("inbox_size"), int) else 0

        if last_run != rd:
            # Reset when switching runs
            items = []
            utd_size = 0
            inbox_size = 0

        # UI-governed tailing (default OFF). If tail_chat is False, render from in-memory only.
        ui = ui_state or {}
        try:
            tail_enabled = bool(ui.get("tail_chat", False))
        except Exception:
            tail_enabled = False

        if not tail_enabled:
            items = trim_items(items, limit=200)
            view = render_chat_view(items, filt=(filt or "all"))
            return view, {
                "run_dir": rd,
                "utd_size": int(utd_size),
                "inbox_size": int(inbox_size),
                "items": items,
            }

        # Stream UTD macro events (UI explicitly enabled)
        utd_path = os.path.join(rd, "utd_events.jsonl")
        new_utd_recs, new_utd_size = tail_jsonl_bytes(utd_path, utd_size)
        items.extend(items_from_utd_records(new_utd_recs))

        # Stream user inbox (UI explicitly enabled)
        inbox_path = os.path.join(rd, "chat_inbox.jsonl")
        new_inbox_recs, new_inbox_size = tail_jsonl_bytes(inbox_path, inbox_size)
        items.extend(items_from_inbox_records(new_inbox_recs))

        items = trim_items(items, limit=200)
        view = render_chat_view(items, filt=(filt or "all"))

        return view, {
            "run_dir": rd,
            "utd_size": int(new_utd_size),
            "inbox_size": int(new_inbox_size),
            "items": items,
        }]]></content>
    </file>
    <file>
      <path>callbacks/engram.py</path>
      <content><![CDATA[from __future__ import annotations

import os
from dash import Input, Output, State  # noqa: F401
from fum_rt.frontend.utilities.fs_utils import _list_files


def register_engram_callbacks(app):
    """
    Engram path helpers:
      - Populate dropdown options by scanning runs-root for .h5/.npz
      - Keep the free-text input in sync with dropdown selection
    """

    @app.callback(
        Output("rc-load-engram-path", "options"),
        Input("runs-root", "value"),
        Input("poll", "n_intervals"),
        Input("proc-status", "children"),
        State("run-dir", "value"),
        prevent_initial_call=False,
    )
    def on_runs_root_change(runs_root_dir, _n, _proc_status, run_dir):
        """
        Keep engram dropdown options fresh:
        - Rescan on runs-root changes
        - Rescan periodically (poll)
        - Rescan on process status transitions (Start/Resume)
        Also include current run_dir tree when it falls outside runs_root.
        """
        options = []
        seen = set()

        # 1) Scan runs_root recursively
        if runs_root_dir and os.path.isdir(runs_root_dir):
            try:
                engram_files = _list_files(runs_root_dir, exts=[".h5", ".npz"], recursive=True)
            except Exception:
                engram_files = []
            for rel_path in engram_files:
                full_path = os.path.join(runs_root_dir, rel_path)
                if full_path in seen:
                    continue
                seen.add(full_path)
                options.append({"label": rel_path.replace(os.path.sep, "/"), "value": full_path})

        # 2) Also scan active run_dir if provided and not already covered
        rd = (run_dir or "").strip()
        if rd and os.path.isdir(rd):
            try:
                rd_files = _list_files(rd, exts=[".h5", ".npz"], recursive=True)
            except Exception:
                rd_files = []
            # If rd lies under runs_root_dir, the above scan likely covered it; de-dup via 'seen'
            base = os.path.basename(rd.rstrip(os.path.sep))
            for rel_path in rd_files:
                full_path = os.path.join(rd, rel_path)
                if full_path in seen:
                    continue
                seen.add(full_path)
                label = f"{base}/{rel_path.replace(os.path.sep, '/')}"
                options.append({"label": label, "value": full_path})

        return options

    @app.callback(
        Output("rc-load-engram-input", "value", allow_duplicate=True),
        Input("rc-load-engram-path", "value"),
        prevent_initial_call=True,
    )
    def sync_engram_input_from_dropdown(val):
        return val]]></content>
    </file>
    <file>
      <path>callbacks/feed.py</path>
      <content><![CDATA[from __future__ import annotations

import os
from dash import Input, Output, State, no_update  # noqa: F401
from fum_rt.frontend.utilities.pdf_utils import convert_pdf_to_text_file


def register_feed_callbacks(app, manager, repo_root: str):
    """
    Feed controls:
      - Start feeding a file into the managed process stdin at a given rate
      - Stop feeding
    Uses the same IDs as the inline version in fum_live to preserve behavior.
    """

    @app.callback(
        Output("send-status", "children", allow_duplicate=True),
        Input("feed-start", "n_clicks"),
        State("feed-path", "value"),
        State("feed-rate", "value"),
        prevent_initial_call=True,
    )
    def on_feed_start(_n, path, rate):
        p = (path or "").strip()
        if not p:
            return "Provide a feed path (relative to fum_rt/data or absolute)."
        chosen = p
        try:
            if (not os.path.isabs(chosen)) or (not os.path.exists(chosen)):
                data_dir = os.path.join(repo_root, "fum_rt", "data")
                cand = os.path.join(data_dir, p)
                if os.path.exists(cand):
                    chosen = cand
        except Exception:
            pass

        # If a PDF is selected, convert to text (best-effort with graceful fallback) before feeding
        status_prefix = ""
        try:
            if chosen.lower().endswith(".pdf"):
                out_dir = os.path.join(repo_root, "outputs", "pdf_text")
                os.makedirs(out_dir, exist_ok=True)
                txt_path, method = convert_pdf_to_text_file(chosen, out_dir)
                if txt_path:
                    status_prefix = f"Converted PDF via {method}; "
                    chosen = txt_path
                else:
                    return "PDF conversion failed (install PyMuPDF/pdfminer.six/PyPDF2 or pytesseract+pdf2image)."
        except Exception:
            return "PDF conversion failed."

        ok = manager.feed_file(chosen, float(rate or 20.0))
        return f"{status_prefix}Feeding from {chosen}." if ok else "Feed failed (check process running and path)."

    @app.callback(
        Output("send-status", "children", allow_duplicate=True),
        Input("feed-stop", "n_clicks"),
        prevent_initial_call=True,
    )
    def on_feed_stop(_n):
        manager.stop_feed()
        return "Feed stopped."]]></content>
    </file>
    <file>
      <path>callbacks/file_picker/__init__.py</path>
      <content><![CDATA[from __future__ import annotations

"""
File Picker callbacks package.

Exports:
- register_file_picker_static
- register_file_picker_engram

Implementation files:
- common.py      (shared callback logic: navigation, tree rendering, status, confirm)
- registrars.py  (thin wrappers: static and dynamic/engram root selection)
"""

from .registrars import (
    register_file_picker_static,
    register_file_picker_engram,
)

__all__ = ["register_file_picker_static", "register_file_picker_engram"]]]></content>
    </file>
    <file>
      <path>callbacks/file_picker/common.py</path>
      <content><![CDATA[from __future__ import annotations

"""
File Picker Common Callback Registrar (package-scoped)

Shared callback logic:
- Navigation (root/up/open-dir)
- Tree render (bounded IO; no recursion)
- Breadcrumbs
- Status computation (dir vs file)
- File click and Confirm

Design:
- Bounded IO (single-directory listings only)
- No scans in core/ or maps/ (enforced in controllers)
"""

import os
from typing import List

import dash
from dash import html, Input, Output, State, ALL, no_update

# Widgets
from fum_rt.frontend.components.widgets.file_picker import _modal_styles as _fp_modal_styles
from fum_rt.frontend.components.widgets.file_tree import dir_row as _w_dir_row, file_row as _w_file_row
from fum_rt.frontend.components.widgets.file_breadcrumbs import breadcrumbs as _w_breadcrumbs

# Controllers (bounded IO + guards)
from fum_rt.frontend.controllers.file_picker_controller import (
    clamp_to_root as _ctl_clamp,
    list_dir as _ctl_list_dir,
    next_children as _ctl_next_children,
)

# Controller helpers for ctx parsing and status formatting
from fum_rt.frontend.controllers.file_picker_ctx import get_trigger_id_obj as _get_ctx_obj
from fum_rt.frontend.controllers.file_picker_status import (
    file_status_text as _file_status_text,
    directory_status_text as _dir_status_text,
)


def register_file_picker_common(app, prefix: str, target_id: str, project_root: str) -> None:
    """
    Register navigation, list population, cancel, file click, and confirm callbacks
    for a file-picker instance. The 'open' callbacks (static/dynamic) are provided by registrars.

    Args:
      app: Dash app
      prefix: ID prefix for this instance
      target_id: Component id whose options/value will be updated on Confirm
      project_root: Absolute repository root for global clamp
    """
    mid = f"{prefix}-modal"
    root_store = f"{prefix}-root"
    cwd_store = f"{prefix}-cwd"
    exts_store = f"{prefix}-exts"
    dirs_dd = f"{prefix}-dirs"
    files_dd = f"{prefix}-files"
    cwd_label = f"{prefix}-cwd-label"
    status_div = f"{prefix}-status"
    up_btn = f"{prefix}-up-btn"
    root_btn = f"{prefix}-root-btn"
    open_dir_btn = f"{prefix}-open-dir-btn"
    cancel_btn = f"{prefix}-cancel-btn"
    confirm_btn = f"{prefix}-confirm-btn"
    sel_store = f"{prefix}-selected-path"
    sel_label = f"{prefix}-selected-label"
    dir_sel_store = f"{prefix}-dir-sel"
    file_sel_store = f"{prefix}-file-sel"
    sel_dir_store = f"{prefix}-selected-dir"
    tree_store = f"{prefix}-tree-store"
    last_action_store = f"{prefix}-last-action"

    def _clamp_to_project(path: str) -> str:
        return _ctl_clamp(path, project_root)

    # Cancel -> hide modal
    @app.callback(
        Output(mid, "style", allow_duplicate=True),
        Input(cancel_btn, "n_clicks"),
        prevent_initial_call=True,
    )
    def on_cancel(_n):
        style = _fp_modal_styles()
        # Keep 'display' as defined by component default (hidden)
        return style

    # Navigate to root
    @app.callback(
        Output(cwd_store, "data", allow_duplicate=True),
        Input(root_btn, "n_clicks"),
        State(root_store, "data"),
        prevent_initial_call=True,
    )
    def on_root(_n, root):
        r = (root or "").strip()
        return _clamp_to_project(os.path.abspath(r)) if r else no_update

    # Navigate up
    @app.callback(
        Output(cwd_store, "data", allow_duplicate=True),
        Input(up_btn, "n_clicks"),
        State(cwd_store, "data"),
        State(root_store, "data"),
        prevent_initial_call=True,
    )
    def on_up(_n, cwd, root):
        c = (cwd or "").strip()
        r = (root or "").strip()
        if not c or not r:
            return no_update
        parent = os.path.dirname(os.path.abspath(c))
        return _ctl_clamp(parent, r)

    # Open selected subfolder
    @app.callback(
        Output(cwd_store, "data", allow_duplicate=True),
        Input(open_dir_btn, "n_clicks"),
        State(dir_sel_store, "data"),
        State(cwd_store, "data"),
        State(root_store, "data"),
        prevent_initial_call=True,
    )
    def on_open_dir(_n, sel, cwd, root):
        s = (sel or "").strip()
        c = (cwd or "").strip()
        r = (root or "").strip()
        if not s or not c:
            return no_update
        cand = os.path.join(c, s)
        if os.path.isdir(cand):
            return _ctl_clamp(cand, r or cand)
        return no_update

    # Render a single tree (folders + files) with breadcrumbs; bounded IO (no scans here)
    @app.callback(
        Output(f"{prefix}-dirs-list", "children"),
        Output(cwd_label, "children"),
        Output(f"{prefix}-crumbs", "children"),
        Output(status_div, "children", allow_duplicate=True),
        Input(tree_store, "data"),
        Input(sel_dir_store, "data"),
        Input(exts_store, "data"),
        Input(file_sel_store, "data"),
        Input(last_action_store, "data"),
        State(root_store, "data"),
        prevent_initial_call=True,
    )
    def on_render(tree_data, selected_dir, exts, file_sel, last_action, root):
        # Resolve root and selected directory (clamped to project root)
        try:
            rabs_in = os.path.abspath((root or "").strip()) if root else None
        except Exception:
            rabs_in = None
        rabs = _clamp_to_project(rabs_in or project_root)
        s_in = (selected_dir or "").strip()
        s = os.path.abspath(s_in) if s_in else rabs
        s = _ctl_clamp(s, rabs)

        # Build tree UI from cached nodes only (no os.listdir here)
        nodes = {}
        try:
            if isinstance(tree_data, dict):
                nodes = dict(tree_data.get("nodes") or {})
                if rabs is None and tree_data.get("root"):
                    rabs = tree_data.get("root")
        except Exception:
            nodes = {}

        allow_all = not exts
        lowered_exts = [e.lower() for e in (exts or [])]

        tree_children = []

        def _build(path: str, depth: int):
            label = os.path.basename(path) or path
            node = nodes.get(path, {})
            expanded = bool(node.get("expanded"))
            is_sel = os.path.abspath(path) == s
            tree_children.append(_w_dir_row(prefix, path, label, depth, expanded, is_sel))
            if expanded:
                # Render subdirectories first
                for child in (node.get("subdirs") or []):
                    try:
                        ch = os.path.join(path, child)
                    except Exception:
                        continue
                    _build(ch, depth + 1)
                # Then render files belonging to this directory.
                # Use cached node files; if absent, do a bounded one-step listing with ext filter & dotfile hiding.
                files_all = node.get("files") or []
                if (not files_all) and os.path.isdir(path):
                    try:
                        _subdirs_tmp, files_tmp = _ctl_list_dir(path, exts=(exts or []), hide_dotfiles=True)
                        files_all = files_tmp or []
                    except Exception:
                        files_all = []
                for f in files_all:
                    try:
                        fpath = os.path.join(path, f)
                    except Exception:
                        continue
                    # node files are already ext-filtered; keep downstream filter for robustness
                    if allow_all or any(f.lower().endswith(e) for e in lowered_exts):
                        tree_children.append(_w_file_row(prefix, fpath, depth, (file_sel or "").strip() == fpath))

        start_root = rabs or s
        if start_root:
            if start_root not in nodes:
                nodes[start_root] = {"expanded": True, "subdirs": [], "files": []}
            _build(start_root, 0)

        cwd_label_text = f"cwd: {s}" if s and os.path.isdir(s) else "cwd: (missing)"

        # Breadcrumbs based on root and selected directory (widgetized)
        try:
            base = os.path.abspath((rabs or s) or "")
            sel = os.path.abspath(s or base)
            crumbs = _w_breadcrumbs(prefix, base, sel)
        except Exception:
            crumbs = []

        # Metadata statusbar — centralized with robust gating (only show file when it belongs to the selected dir)
        fsel = (file_sel or "").strip()
        try:
            s_abs = os.path.abspath(s) if s else ""
            fsel_abs = os.path.abspath(fsel) if fsel else ""
            fsel_dir_abs = os.path.abspath(os.path.dirname(fsel_abs)) if fsel_abs else ""
        except Exception:
            s_abs, fsel_abs, fsel_dir_abs = "", "", ""
        if (last_action == "file") and fsel_abs and os.path.isfile(fsel_abs) and (fsel_dir_abs == s_abs):
            status_text = _file_status_text(fsel_abs)
        else:
            status_text = _dir_status_text(s, exts=(exts or []), hide_dotfiles=True)
        return tree_children, cwd_label_text, crumbs, status_text

    # Tree toggle: expand/collapse one node; cache listing on expand (one directory at a time)
    @app.callback(
        Output(tree_store, "data", allow_duplicate=True),
        Output(sel_dir_store, "data", allow_duplicate=True),
        Output(file_sel_store, "data", allow_duplicate=True),
        Output(f"{prefix}-last-action", "data", allow_duplicate=True),
        Output(status_div, "children", allow_duplicate=True),
        Input({"role": f"{prefix}-tree-dir", "path": ALL}, "n_clicks"),
        State(tree_store, "data"),
        State(root_store, "data"),
        State(exts_store, "data"),
        prevent_initial_call=True,
    )
    def on_tree_toggle(_clicks, tree_data, root, exts):
        ctx = dash.callback_context
        obj = _get_ctx_obj(ctx)
        if not isinstance(obj, dict) or obj.get("role") != f"{prefix}-tree-dir":
            return no_update, no_update, no_update, no_update
        target = (obj.get("path", "") or "").strip()
        if not target:
            return no_update, no_update, no_update, no_update

        r = (root or "").strip()
        rabs0 = os.path.abspath(r) if r else os.path.abspath(target)
        rabs = _clamp_to_project(rabs0)

        # Initialize tree structure if needed
        tree = tree_data if isinstance(tree_data, dict) else {}
        if not tree:
            tree = {"root": rabs, "nodes": {}}
        nodes = tree.get("nodes") or {}
        tree["root"] = tree.get("root") or rabs

        # Clamp and toggle
        p = _ctl_clamp(target, rabs)
        node = dict(nodes.get(p) or {})
        # Never collapse the root node to avoid "everything disappears" UX
        if os.path.abspath(p) == os.path.abspath(rabs):
            node["expanded"] = True
        else:
            toggled = not bool(node.get("expanded"))
            node["expanded"] = toggled
        if node.get("expanded") and (not node.get("subdirs") or not node.get("files")):
            # Bounded IO: list this node's direct children once on expansion (ext-filtered, dotfiles hidden)
            subdirs, files_all = _ctl_next_children(p, exts=(exts or []), hide_dotfiles=True)
            node["subdirs"] = subdirs or []
            node["files"] = files_all or []
        nodes[p] = node
        tree["nodes"] = nodes
        # Also clear any existing file selection on folder toggle so status shows folder metadata
        return tree, p, "", "nav", _dir_status_text(p, exts=(exts or []), hide_dotfiles=True)

    # Breadcrumb click -> select directory (clamped)
    @app.callback(
        Output(sel_dir_store, "data", allow_duplicate=True),
        Output(f"{prefix}-last-action", "data", allow_duplicate=True),
        Input({"role": f"{prefix}-crumb", "path": ALL}, "n_clicks"),
        State(root_store, "data"),
        prevent_initial_call=True,
    )
    def on_crumb_click(_clicks, root):
        ctx = dash.callback_context
        obj = _get_ctx_obj(ctx)
        if not isinstance(obj, dict) or obj.get("role") != f"{prefix}-crumb":
            return no_update, no_update
        target = (obj.get("path", "") or "").strip()
        if not target:
            return no_update, no_update
        r = (root or "").strip()
        if r:
            return _ctl_clamp(target, r), "nav"
        return target, "nav"

    # Sync selected-dir when legacy cwd changes (Root/Up)
    @app.callback(
        Output(sel_dir_store, "data", allow_duplicate=True),
        Output(file_sel_store, "data", allow_duplicate=True),
        Output(f"{prefix}-last-action", "data", allow_duplicate=True),
        Input(cwd_store, "data"),
        State(root_store, "data"),
        prevent_initial_call=True,
    )
    def sync_selected_dir(cwd, root):
        c = (cwd or "").strip()
        r = (root or "").strip()
        if not c:
            return no_update, no_update, no_update
        c = _clamp_to_project(c)
        if r:
            r = _clamp_to_project(r)
            return _ctl_clamp(c, r), "", "nav"
        return c, "", "nav"

    # Clear stale file selection when directory changes
    @app.callback(
        Output(file_sel_store, "data", allow_duplicate=True),
        Input(sel_dir_store, "data"),
        prevent_initial_call=True,
    )
    def _clear_file_sel_on_dir_change(_sel):
        return ""

    # Click handlers for files inside the tree
    @app.callback(
        Output(dir_sel_store, "data"),
        Output(file_sel_store, "data", allow_duplicate=True),
        Output(status_div, "children", allow_duplicate=True),
        Output(f"{prefix}-last-action", "data", allow_duplicate=True),
        Output(sel_store, "data", allow_duplicate=True),
        Output(sel_label, "children", allow_duplicate=True),
        Input({"role": f"{prefix}-file", "path": ALL}, "n_clicks"),
        prevent_initial_call=True,
    )
    def on_explorer_click(_file_clicks):
        ctx = dash.callback_context

        # Parse triggering id; avoid strict n_clicks gating which can be None or string in some Dash versions
        obj = _get_ctx_obj(ctx)
        if not isinstance(obj, dict) or obj.get("role") != f"{prefix}-file":
            return no_update, no_update, no_update, no_update, no_update, no_update
        fpath = (obj.get("path", "") or "").strip()
        if not fpath:
            return no_update, no_update, no_update, no_update, no_update, no_update
        # Persist selection into stores so Confirm has a reliable fallback
        from os.path import basename
        return no_update, fpath, no_update, "file", fpath, basename(fpath)

    # Confirm selection -> set stores, hide modal, and update target value
    @app.callback(
        Output(sel_store, "data"),
        Output(sel_label, "children"),
        Output(status_div, "children", allow_duplicate=True),
        Output(mid, "style", allow_duplicate=True),
        Output(target_id, "options", allow_duplicate=True),
        Output(target_id, "value", allow_duplicate=True),
        Input(confirm_btn, "n_clicks"),
        State(file_sel_store, "data"),
        State(sel_dir_store, "data"),
        State(target_id, "options"),
        State(sel_store, "data"),
        prevent_initial_call=True,
    )
    def on_confirm(_n, file_sel, sel_dir, options, sel_data):
        # Primary source: file selected by clicking in explorer
        fsel = (file_sel or "").strip()
        # Fallback to last persisted selection (set on click) if primary missing
        if not fsel:
            fsel = (sel_data or "").strip()
        c = (sel_dir or "").strip()
        if not fsel:
            return no_update, no_update, "Select a file.", no_update, no_update, no_update
        path = fsel if os.path.isabs(fsel) else (os.path.abspath(os.path.join(c, fsel)) if c else os.path.abspath(fsel))
        label = os.path.basename(path)

        # Ensure Dropdown 'options' contains the selected path to avoid client-side validation blocking the update
        try:
            existing = options if isinstance(options, list) else []
        except Exception:
            existing = []
        try:
            vals = set()
            new_options = []
            for o in existing:
                if isinstance(o, dict):
                    v = o.get("value")
                    if isinstance(v, str) and v not in vals:
                        vals.add(v)
                        new_options.append(o)
            if path not in vals:
                new_options.append({"label": path, "value": path})
        except Exception:
            new_options = [{"label": path, "value": path}]

        status = f"Selected: {path}"
        style = _fp_modal_styles()  # hidden (default)
        return path, label, status, style, new_options, path]]></content>
    </file>
    <file>
      <path>callbacks/file_picker/registrars.py</path>
      <content><![CDATA[from __future__ import annotations

"""
File Picker Registrars (package-scoped)

- Static root registrar
- Dynamic (engram) root registrar

Both delegate common behavior to .common.register_file_picker_common
"""

import os
from typing import List

from dash import Output, Input, State  # type: ignore

from fum_rt.frontend.components.widgets.file_picker import _modal_styles as _fp_modal_styles
from fum_rt.frontend.controllers.file_picker_controller import init_tree as _ctl_init_tree
from .common import register_file_picker_common


def _project_root_default() -> str:
    """
    Resolve a safe project root for clamping.
    Prefers FUM_PROJECT_ROOT; falls back to repository root by relative path.
    """
    try:
        env = os.path.abspath((os.getenv("FUM_PROJECT_ROOT") or "").strip())
        if env and os.path.isdir(env):
            return env
    except Exception:
        pass
    # callbacks/file_picker/ -> callbacks/ -> frontend/ -> .. (repo root)
    return os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))


def register_file_picker_static(app, prefix: str, root: str, exts: List[str] | None, target_id: str) -> None:
    """
    Register a file-picker with a fixed root (bounded IO).
    """
    project_root = _project_root_default()

    mid = f"{prefix}-modal"
    root_store = f"{prefix}-root"
    cwd_store = f"{prefix}-cwd"
    exts_store = f"{prefix}-exts"
    status_div = f"{prefix}-status"
    open_btn = f"{prefix}-open-btn"

    # Open -> show modal and initialize stores
    @app.callback(
        Output(mid, "style", allow_duplicate=True),
        Output(root_store, "data"),
        Output(cwd_store, "data", allow_duplicate=True),
        Output(exts_store, "data"),
        Output(f"{prefix}-file-sel", "data", allow_duplicate=True),
        Output(f"{prefix}-last-action", "data", allow_duplicate=True),
        Input(open_btn, "n_clicks"),
        prevent_initial_call=True,
    )
    def on_open(_n):
        r0 = os.path.abspath(root or "")
        r = r0 if os.path.isdir(r0) else project_root
        style = _fp_modal_styles()
        style["display"] = "flex"
        return style, r, r, list(exts or []), "", "nav"

    # Initialize tree and selection on open (static)
    @app.callback(
        Output(f"{prefix}-selected-dir", "data", allow_duplicate=True),
        Output(f"{prefix}-tree-store", "data", allow_duplicate=True),
        Output(status_div, "children", allow_duplicate=True),
        Input(open_btn, "n_clicks"),
        prevent_initial_call=True,
    )
    def on_open_init(_n):
        r0 = os.path.abspath(root or "")
        r = r0 if os.path.isdir(r0) else project_root
        tree = _ctl_init_tree(r, exts=(exts or []), hide_dotfiles=True)
        try:
            files0 = (tree.get("nodes", {}).get(r, {}) or {}).get("files") or []
            status_text = f"root: {r}  files: {len(files0)}"
        except Exception:
            status_text = f"root: {r}  files: 0"
        return r, tree, status_text

    register_file_picker_common(app, prefix, target_id, project_root)


def register_file_picker_engram(
    app,
    prefix: str,
    exts: List[str] | None,
    target_id: str,
    fallback_root: str,
) -> None:
    """
    Register a file-picker whose root = current run-dir if available, else runs-root, else fallback_root.
    """
    project_root = _project_root_default()

    mid = f"{prefix}-modal"
    root_store = f"{prefix}-root"
    cwd_store = f"{prefix}-cwd"
    exts_store = f"{prefix}-exts"
    status_div = f"{prefix}-status"
    open_btn = f"{prefix}-open-btn"

    # Open -> compute root dynamically from run-dir / runs-root
    @app.callback(
        Output(mid, "style", allow_duplicate=True),
        Output(root_store, "data"),
        Output(cwd_store, "data", allow_duplicate=True),
        Output(exts_store, "data"),
        Output(f"{prefix}-file-sel", "data", allow_duplicate=True),
        Output(f"{prefix}-last-action", "data", allow_duplicate=True),
        Input(open_btn, "n_clicks"),
        State("run-dir", "value"),
        State("runs-root", "value"),
        prevent_initial_call=True,
    )
    def on_open_dynamic(_n, run_dir, runs_root):
        candidates = []
        rd = (run_dir or "").strip()
        rr = (runs_root or "").strip()
        if rd and os.path.isdir(rd):
            candidates.append(rd)
        if rr and os.path.isdir(rr):
            candidates.append(rr)
        if fallback_root:
            candidates.append(fallback_root)
        # choose the first existing (clamped) directory
        for cand in candidates:
            if not cand:
                continue
            r_candidate = os.path.abspath(cand)
            if os.path.isdir(r_candidate):
                r = r_candidate
                style = _fp_modal_styles()
                style["display"] = "flex"
                return style, r, r, list(exts or []), "", "nav"
        # fallback: open at project root
        style = _fp_modal_styles()
        style["display"] = "flex"
        return style, project_root, project_root, list(exts or []), "", "nav"

    # Initialize tree and selection on open (dynamic)
    @app.callback(
        Output(f"{prefix}-selected-dir", "data", allow_duplicate=True),
        Output(f"{prefix}-tree-store", "data", allow_duplicate=True),
        Output(status_div, "children", allow_duplicate=True),
        Input(open_btn, "n_clicks"),
        State("run-dir", "value"),
        State("runs-root", "value"),
        prevent_initial_call=True,
    )
    def on_open_init_dynamic(_n, run_dir, runs_root):
        candidates = []
        rd = (run_dir or "").strip()
        rr = (runs_root or "").strip()
        if rd and os.path.isdir(rd):
            candidates.append(rd)
        if rr and os.path.isdir(rr):
            candidates.append(rr)
        if fallback_root:
            candidates.append(fallback_root)
        for cand in candidates:
            if not cand:
                continue
            r = os.path.abspath(cand)
            if os.path.isdir(r):
                tree = _ctl_init_tree(r, exts=(exts or []), hide_dotfiles=True)
                try:
                    files0 = (tree.get("nodes", {}).get(r, {}) or {}).get("files") or []
                    status_text = f"root: {r}  files: {len(files0)}"
                except Exception:
                    status_text = f"root: {r}  files: 0"
                return r, tree, status_text
        r = project_root
        tree = _ctl_init_tree(r, exts=(exts or []), hide_dotfiles=True)
        try:
            files0 = (tree.get("nodes", {}).get(r, {}) or {}).get("files") or []
            status_text = f"root: {r}  files: {len(files0)}"
        except Exception:
            status_text = f"root: {r}  files: 0"
        return r, tree, status_text

    register_file_picker_common(app, prefix, target_id, project_root)]]></content>
    </file>
    <file>
      <path>callbacks/interval.py</path>
      <content><![CDATA[from __future__ import annotations

from typing import Any
from dash import Input, Output  # noqa: F401


def _int_or(v: Any, dv: int) -> int:
    try:
        return int(v)
    except Exception:
        return dv


def register_interval_callbacks(app):
    """
    Bind dcc.Interval(id="poll") cadence to UI Performance settings (ui-state).
    - update_ms <= 0 disables polling
    - update_ms > 0 sets the interval in milliseconds (min clamp = 100 ms)
    This replaces the env-only cadence for responsiveness control without restart.
    """
    @app.callback(
        Output("poll", "interval"),
        Output("poll", "disabled"),
        Input("ui-state", "data"),
        prevent_initial_call=False,
    )
    def on_ui_interval(ui_state: dict | None):
        ui = ui_state or {}
        update_ms = _int_or(ui.get("update_ms", 800), 800)
        if update_ms <= 0:
            # Disable polling entirely
            return 100, True  # Dash requires a valid interval even if disabled
        # Enforce a sane lower bound
        return int(max(100, update_ms)), False


__all__ = ["register_interval_callbacks"]]]></content>
    </file>
    <file>
      <path>callbacks/logs.py</path>
      <content><![CDATA[from __future__ import annotations

import os
from dash import Input, Output  # noqa: F401


def register_logs_callbacks(app, manager):
    """
    Launcher log viewer:
      - Streams the tail of the last launcher log written by ProcessManager.
    IDs preserved to match existing layout.
    """

    @app.callback(
        Output("launch-log", "children"),
        Input("poll", "n_intervals"),
        Input("show-log", "n_clicks"),
        Input("ui-state", "data"),
        prevent_initial_call=False,
    )
    def update_launch_log(_n, _clicks, ui_state):
        """
        Tail the launcher log efficiently without rereading entire file each tick.
        - UI-governed: only tails when ui_state['tail_launch_log'] is True (default OFF).
        - Bounds bytes via DASH_LOG_TAIL_BYTES (env) while staying purely UI-controlled for enable/disable.
        - One-shot behavior on "Show Launcher Log" click: shows once, then reverts to UI toggle gating.
        """
        ui = ui_state or {}
        clicks = int(_clicks or 0)

        # One-shot gating: only tail on button press transitions, or when toggle is ON.
        try:
            last_clicks = int(getattr(update_launch_log, "_last_clicks", 0))
        except Exception:
            last_clicks = 0
        one_shot = clicks > last_clicks
        try:
            setattr(update_launch_log, "_last_clicks", clicks)
        except Exception:
            pass

        try:
            tail_enabled = bool(ui.get("tail_launch_log", False))
        except Exception:
            tail_enabled = False

        if not (tail_enabled or one_shot):
            return "Launcher log tail disabled (toggle in UI Performance or click Show Launcher Log)."

        try:
            path = getattr(manager, "launch_log", None)
            if not path or not os.path.exists(path):
                return "No launcher log yet."

            try:
                tail_bytes = int(os.getenv("DASH_LOG_TAIL_BYTES", "16384"))
            except Exception:
                tail_bytes = 16384

            st = os.stat(path)
            size = int(getattr(st, "st_size", 0))
            start = max(0, size - max(1024, tail_bytes))  # at least 1 KiB

            with open(path, "rb") as fh:
                fh.seek(start, os.SEEK_SET)
                data = fh.read()

            text = data.decode("utf-8", errors="ignore")
            # Keep a compact tail to avoid heavy DOM nodes
            return text[-4000:] if len(text) > 4000 else text
        except Exception as e:
            return f"Error reading launcher log: {e}"]]></content>
    </file>
    <file>
      <path>callbacks/perf.py</path>
      <content><![CDATA[from __future__ import annotations

from typing import Any, Dict, List
from dash import Input, Output  # noqa: F401


def _is_on(v: Any) -> bool:
    try:
        return isinstance(v, list) and ("on" in v)
    except Exception:
        return False


def _int_or(v: Any, dv: int) -> int:
    try:
        i = int(v)
        return i
    except Exception:
        return dv


def _float_or(v: Any, dv: float) -> float:
    try:
        f = float(v)
        return f
    except Exception:
        return dv


def _str_or(v: Any, dv: str) -> str:
    try:
        s = str(v).strip()
        return s if s else dv
    except Exception:
        return dv


def register_perf_callbacks(app):
    """
    Mirror UI Performance controls into dcc.Store(id="ui-state").
    No environment variables are required; settings apply immediately.
    """
    @app.callback(
        Output("ui-state", "data"),
        Input("ui-charts-http", "value"),
        Input("ui-update-ms", "value"),
        Input("ui-points-cap", "value"),
        Input("ui-series-cap", "value"),
        Input("ui-status-url", "value"),
        Input("ui-status-timeout", "value"),
        Input("ui-tail-chat", "value"),
        Input("ui-tail-launch", "value"),
        prevent_initial_call=False,
    )
    def on_perf_update(
        charts_http_v: List[str],
        update_ms_v: Any,
        points_cap_v: Any,
        series_cap_v: Any,
        status_url_v: Any,
        status_timeout_v: Any,
        tail_chat_v: List[str],
        tail_launch_v: List[str],
    ):
        charts_http = _is_on(charts_http_v)
        tail_chat = _is_on(tail_chat_v)
        tail_launch_log = _is_on(tail_launch_v)
        update_ms = _int_or(update_ms_v, 800)
        points_cap = _int_or(points_cap_v, 1200)
        series_cap = _int_or(series_cap_v, 6)
        status_url = _str_or(status_url_v, "http://127.0.0.1:8787/status/snapshot")
        status_timeout = _float_or(status_timeout_v, 0.2)

        # Provide keys consumed by charts controller (maxp/decimate)
        ui: Dict[str, Any] = {
            "charts_http_only": bool(charts_http),
            "update_ms": int(max(100, update_ms)),
            "points_cap": int(max(50, points_cap)),
            "series_cap": int(max(1, series_cap)),
            "tail_chat": bool(tail_chat),
            "tail_launch_log": bool(tail_launch_log),
            "status_url": status_url,
            "status_timeout": float(max(0.05, status_timeout)),
            # Charts controller knobs (no env):
            "maxp": int(max(50, points_cap)),
            "decimate": int(max(0, points_cap)),  # treat as target plotted points (0=off if caller wants)
        }
        return ui


__all__ = ["register_perf_callbacks"]]]></content>
    </file>
    <file>
      <path>callbacks/process.py</path>
      <content><![CDATA[from __future__ import annotations

import os
import dash
from typing import Any, Dict, Tuple
from dash import Input, Output, State, no_update  # noqa: F401 (bound at runtime)

from fum_rt.frontend.utilities.profiles import assemble_profile as _assemble_profile, safe_int as _safe_int, safe_float as _safe_float
from fum_rt.frontend.utilities.fs_utils import latest_checkpoint


def register_process_callbacks(app, runs_root: str, manager, default_profile: Dict[str, Any]):
    """
    Process lifecycle callbacks:
      - Start New Run
      - Resume Selected Run
      - Stop Managed Run
    Depends on:
      - manager: ProcessManager instance
      - runs_root: initial runs root (UI may update manager later)
      - default_profile: dict of defaults for assembling profiles
    """

    def _start_or_resume(profile: Dict[str, Any]) -> Tuple[str, Any]:
        ok, msg = manager.start(profile)
        if not ok:
            return f"Start failed:\n{msg}", no_update
        rd = profile.get("run_dir") or msg
        cmd_echo = " ".join(manager.last_cmd or [])
        status = (
            f"Started.\nrun_dir={rd}\n"
            f"checkpoint_every={profile.get('checkpoint_every')} keep={profile.get('checkpoint_keep')}\n"
            f"cmd: {cmd_echo}\n"
            f"launch_log: {manager.launch_log}"
        )
        return status, rd or no_update

    @app.callback(
        Output("proc-status", "children", allow_duplicate=True),
        Output("run-dir", "value", allow_duplicate=True),
        Input("start-run", "n_clicks"),
        State("runs-root", "value"),
        State("cfg-neurons", "value"),
        State("cfg-k", "value"),
        State("cfg-hz", "value"),
        State("cfg-domain", "value"),
        State("cfg-use-time-dynamics", "value"),
        State("cfg-sparse-mode", "value"),
        State("cfg-threshold", "value"),
        State("cfg-lambda-omega", "value"),
        State("cfg-candidates", "value"),
        State("cfg-walkers", "value"),
        State("cfg-hops", "value"),
        State("cfg-status-interval", "value"),
        State("cfg-bundle-size", "value"),
        State("cfg-prune-factor", "value"),
        State("cfg-stim-group-size", "value"),
        State("cfg-stim-amp", "value"),
        State("cfg-stim-decay", "value"),
        State("cfg-stim-max-symbols", "value"),
        State("cfg-speak-auto", "value"),
        State("cfg-speak-z", "value"),
        State("cfg-speak-hysteresis", "value"),
        State("cfg-speak-cooldown-ticks", "value"),
        State("cfg-speak-valence-thresh", "value"),
        State("cfg-b1-half-life-ticks", "value"),
        State("cfg-viz-every", "value"),
        State("cfg-log-every", "value"),
        State("cfg-checkpoint-every", "value"),
        State("cfg-checkpoint-keep", "value"),
        State("cfg-duration", "value"),
        State("rc-load-engram-path", "value"),
        State("rc-load-engram-input", "value"),
        prevent_initial_call=True,
    )
    def on_start_run(
        n_start,
        root,
        neurons,
        k,
        hz,
        domain,
        use_td,
        sparse_mode,
        threshold,
        lambda_omega,
        candidates,
        walkers,
        hops,
        status_interval,
        bundle_size,
        prune_factor,
        stim_group_size,
        stim_amp,
        stim_decay,
        stim_max_symbols,
        speak_auto,
        speak_z,
        speak_hyst,
        speak_cd,
        speak_val,
        b1_hl,
        viz_every,
        log_every,
        checkpoint_every,
        checkpoint_keep,
        duration,
        load_engram_path,
        load_engram_input,
    ):
        if not n_start:
            raise dash.exceptions.PreventUpdate
        if root:
            try:
                manager.set_runs_root(root)
            except Exception:
                pass

        profile = _assemble_profile(
            neurons,
            k,
            hz,
            domain,
            use_td,
            sparse_mode,
            threshold,
            lambda_omega,
            candidates,
            walkers,
            hops,
            status_interval,
            bundle_size,
            prune_factor,
            stim_group_size,
            stim_amp,
            stim_decay,
            stim_max_symbols,
            speak_auto,
            speak_z,
            speak_hyst,
            speak_cd,
            speak_val,
            b1_hl,
            viz_every,
            log_every,
            checkpoint_every,
            checkpoint_keep,
            duration,
            default_profile,
        )

        lep = (load_engram_input or load_engram_path)
        if lep:
            profile["load_engram"] = lep
            # Adopt the folder as run_dir so the whole bundle (events, lexicon, macro board) is reused.
            try:
                p = str(lep).strip()
                if p:
                    adopt_dir = p if os.path.isdir(p) else os.path.dirname(p)
                    if adopt_dir:
                        profile["run_dir"] = adopt_dir
            except Exception:
                pass

        return _start_or_resume(profile)

    @app.callback(
        Output("proc-status", "children", allow_duplicate=True),
        Output("run-dir", "value", allow_duplicate=True),
        Input("resume-run", "n_clicks"),
        State("runs-root", "value"),
        State("run-dir", "value"),
        State("cfg-neurons", "value"),
        State("cfg-k", "value"),
        State("cfg-hz", "value"),
        State("cfg-domain", "value"),
        State("cfg-use-time-dynamics", "value"),
        State("cfg-sparse-mode", "value"),
        State("cfg-threshold", "value"),
        State("cfg-lambda-omega", "value"),
        State("cfg-candidates", "value"),
        State("cfg-walkers", "value"),
        State("cfg-hops", "value"),
        State("cfg-status-interval", "value"),
        State("cfg-bundle-size", "value"),
        State("cfg-prune-factor", "value"),
        State("cfg-stim-group-size", "value"),
        State("cfg-stim-amp", "value"),
        State("cfg-stim-decay", "value"),
        State("cfg-stim-max-symbols", "value"),
        State("cfg-speak-auto", "value"),
        State("cfg-speak-z", "value"),
        State("cfg-speak-hysteresis", "value"),
        State("cfg-speak-cooldown-ticks", "value"),
        State("cfg-speak-valence-thresh", "value"),
        State("cfg-b1-half-life-ticks", "value"),
        State("cfg-viz-every", "value"),
        State("cfg-log-every", "value"),
        State("cfg-checkpoint-every", "value"),
        State("cfg-checkpoint-keep", "value"),
        State("cfg-duration", "value"),
        State("rc-load-engram-path", "value"),
        State("rc-load-engram-input", "value"),
        prevent_initial_call=True,
    )
    def on_resume_run(
        n_resume,
        root,
        run_dir,
        neurons,
        k,
        hz,
        domain,
        use_td,
        sparse_mode,
        threshold,
        lambda_omega,
        candidates,
        walkers,
        hops,
        status_interval,
        bundle_size,
        prune_factor,
        stim_group_size,
        stim_amp,
        stim_decay,
        stim_max_symbols,
        speak_auto,
        speak_z,
        speak_hyst,
        speak_cd,
        speak_val,
        b1_hl,
        viz_every,
        log_every,
        checkpoint_every,
        checkpoint_keep,
        duration,
        load_engram_path,
        load_engram_input,
    ):
        if not n_resume:
            raise dash.exceptions.PreventUpdate
        if root:
            try:
                manager.set_runs_root(root)
            except Exception:
                pass

        rd = (run_dir or "").strip()
        if not rd or not os.path.isdir(rd):
            return "Select an existing run directory to resume.", no_update

        profile = _assemble_profile(
            neurons,
            k,
            hz,
            domain,
            use_td,
            sparse_mode,
            threshold,
            lambda_omega,
            candidates,
            walkers,
            hops,
            status_interval,
            bundle_size,
            prune_factor,
            stim_group_size,
            stim_amp,
            stim_decay,
            stim_max_symbols,
            speak_auto,
            speak_z,
            speak_hyst,
            speak_cd,
            speak_val,
            b1_hl,
            viz_every,
            log_every,
            checkpoint_every,
            checkpoint_keep,
            duration,
            default_profile,
        )
        profile["run_dir"] = rd

        lep = (load_engram_input or load_engram_path)
        if not lep:
            lep = latest_checkpoint(rd)
        if lep:
            profile["load_engram"] = lep

        ok, msg = manager.start(profile)
        if not ok:
            return f"Resume failed:\n{msg}", no_update

        cmd_echo = " ".join(manager.last_cmd or [])
        status = (
            f"Resumed.\nrun_dir={rd}\n"
            f"load_engram={profile.get('load_engram','')}\n"
            f"cmd: {cmd_echo}\n"
            f"launch_log: {manager.launch_log}"
        )
        return status, rd

    @app.callback(
        Output("proc-status", "children", allow_duplicate=True),
        Input("stop-run", "n_clicks"),
        prevent_initial_call=True,
    )
    def on_stop_run(n_stop):
        if not n_stop:
            raise dash.exceptions.PreventUpdate
        ok, msg = manager.stop()
        return "Stopped." if ok else msg]]></content>
    </file>
    <file>
      <path>callbacks/profile.py</path>
      <content><![CDATA[from __future__ import annotations

import os
import dash
from typing import Any, Dict, List
from dash import Input, Output, State  # noqa: F401

from fum_rt.frontend.utilities.fs_utils import read_json_file, write_json_file
from fum_rt.frontend.utilities.profiles import (
    assemble_profile as _assemble_profile,
    checklist_from_bool as _checklist_from_bool,
)


def register_profile_callbacks(app, profiles_dir: str, default_profile: Dict[str, Any]):
    """
    Profile management callbacks:
      - Save current UI config to a named profile under profiles_dir
      - Load a selected profile into the UI config controls

    IDs preserved to match existing layout (fum_live).
    """

    os.makedirs(profiles_dir, exist_ok=True)

    def _list_profiles() -> List[str]:
        try:
            return sorted(
                [
                    os.path.join(profiles_dir, f)
                    for f in os.listdir(profiles_dir)
                    if f.endswith(".json")
                ]
            )
        except Exception:
            return []

    @app.callback(
        Output("profile-path", "options"),
        Output("profile-save-status", "children"),
        Input("save-profile", "n_clicks"),
        State("profile-name", "value"),
        State("cfg-neurons", "value"),
        State("cfg-k", "value"),
        State("cfg-hz", "value"),
        State("cfg-domain", "value"),
        State("cfg-use-time-dynamics", "value"),
        State("cfg-sparse-mode", "value"),
        State("cfg-threshold", "value"),
        State("cfg-lambda-omega", "value"),
        State("cfg-candidates", "value"),
        State("cfg-walkers", "value"),
        State("cfg-hops", "value"),
        State("cfg-status-interval", "value"),
        State("cfg-bundle-size", "value"),
        State("cfg-prune-factor", "value"),
        State("cfg-stim-group-size", "value"),
        State("cfg-stim-amp", "value"),
        State("cfg-stim-decay", "value"),
        State("cfg-stim-max-symbols", "value"),
        State("cfg-speak-auto", "value"),
        State("cfg-speak-z", "value"),
        State("cfg-speak-hysteresis", "value"),
        State("cfg-speak-cooldown-ticks", "value"),
        State("cfg-speak-valence-thresh", "value"),
        State("cfg-b1-half-life-ticks", "value"),
        State("cfg-viz-every", "value"),
        State("cfg-log-every", "value"),
        State("cfg-checkpoint-every", "value"),
        State("cfg-checkpoint-keep", "value"),
        State("cfg-duration", "value"),
        prevent_initial_call=True,
    )
    def on_save_profile(
        _n,
        name,
        neurons,
        k,
        hz,
        domain,
        use_td,
        sparse_mode,
        threshold,
        lambda_omega,
        candidates,
        walkers,
        hops,
        status_interval,
        bundle_size,
        prune_factor,
        stim_group_size,
        stim_amp,
        stim_decay,
        stim_max_symbols,
        speak_auto,
        speak_z,
        speak_hyst,
        speak_cd,
        speak_val,
        b1_hl,
        viz_every,
        log_every,
        checkpoint_every,
        checkpoint_keep,
        duration,
    ):
        name = (name or "").strip()
        if not name:
            return [{"label": os.path.basename(p), "value": p} for p in _list_profiles()], "Provide a profile name."
        data = _assemble_profile(
            neurons,
            k,
            hz,
            domain,
            use_td,
            sparse_mode,
            threshold,
            lambda_omega,
            candidates,
            walkers,
            hops,
            status_interval,
            bundle_size,
            prune_factor,
            stim_group_size,
            stim_amp,
            stim_decay,
            stim_max_symbols,
            speak_auto,
            speak_z,
            speak_hyst,
            speak_cd,
            speak_val,
            b1_hl,
            viz_every,
            log_every,
            checkpoint_every,
            checkpoint_keep,
            duration,
            default_profile,
        )
        path = os.path.join(profiles_dir, f"{name}.json")
        ok = write_json_file(path, data)
        status = f"Saved profile to {path}" if ok else f"Error writing {path}"
        return [{"label": os.path.basename(p), "value": p} for p in _list_profiles()], status

    @app.callback(
        Output("cfg-neurons", "value"),
        Output("cfg-k", "value"),
        Output("cfg-hz", "value"),
        Output("cfg-domain", "value"),
        Output("cfg-use-time-dynamics", "value"),
        Output("cfg-sparse-mode", "value"),
        Output("cfg-threshold", "value"),
        Output("cfg-lambda-omega", "value"),
        Output("cfg-candidates", "value"),
        Output("cfg-walkers", "value"),
        Output("cfg-hops", "value"),
        Output("cfg-status-interval", "value"),
        Output("cfg-bundle-size", "value"),
        Output("cfg-prune-factor", "value"),
        Output("cfg-stim-group-size", "value"),
        Output("cfg-stim-amp", "value"),
        Output("cfg-stim-decay", "value"),
        Output("cfg-stim-max-symbols", "value"),
        Output("cfg-speak-auto", "value"),
        Output("cfg-speak-z", "value"),
        Output("cfg-speak-hysteresis", "value"),
        Output("cfg-speak-cooldown-ticks", "value"),
        Output("cfg-speak-valence-thresh", "value"),
        Output("cfg-b1-half-life-ticks", "value"),
        Output("cfg-viz-every", "value"),
        Output("cfg-log-every", "value"),
        Output("cfg-checkpoint-every", "value"),
        Output("cfg-checkpoint-keep", "value"),
        Output("cfg-duration", "value"),
        Output("profile-save-status", "children", allow_duplicate=True),
        Input("load-profile", "n_clicks"),
        Input("profile-path", "value"),
        Input("profile-file-selected-label", "children"),
        prevent_initial_call=True,
    )
    def on_load_profile(_n, path, _sel_label):
        if not path:
            raise dash.exceptions.PreventUpdate
        data = read_json_file(path) or {}

        def g(k, dv):
            v = data.get(k, dv)
            return v if v is not None else dv

        return (
            g("neurons", default_profile["neurons"]),
            g("k", default_profile["k"]),
            g("hz", default_profile["hz"]),
            g("domain", default_profile["domain"]),
            _checklist_from_bool(bool(g("use_time_dynamics", default_profile["use_time_dynamics"]))),
            _checklist_from_bool(bool(g("sparse_mode", default_profile["sparse_mode"]))),
            g("threshold", default_profile["threshold"]),
            g("lambda_omega", default_profile["lambda_omega"]),
            g("candidates", default_profile["candidates"]),
            g("walkers", default_profile["walkers"]),
            g("hops", default_profile["hops"]),
            g("status_interval", default_profile["status_interval"]),
            g("bundle_size", default_profile["bundle_size"]),
            g("prune_factor", default_profile["prune_factor"]),
            g("stim_group_size", default_profile["stim_group_size"]),
            g("stim_amp", default_profile["stim_amp"]),
            g("stim_decay", default_profile["stim_decay"]),
            g("stim_max_symbols", default_profile["stim_max_symbols"]),
            _checklist_from_bool(bool(g("speak_auto", default_profile["speak_auto"]))),
            g("speak_z", default_profile["speak_z"]),
            g("speak_hysteresis", default_profile["speak_hysteresis"]),
            g("speak_cooldown_ticks", default_profile["speak_cooldown_ticks"]),
            g("speak_valence_thresh", default_profile["speak_valence_thresh"]),
            g("b1_half_life_ticks", default_profile["b1_half_life_ticks"]),
            g("viz_every", default_profile["viz_every"]),
            g("log_every", default_profile["log_every"]),
            g("checkpoint_every", default_profile["checkpoint_every"]),
            g("checkpoint_keep", default_profile["checkpoint_keep"]),
            g("duration", default_profile["duration"]),
            f"Loaded profile: {path}",
        )]]></content>
    </file>
    <file>
      <path>callbacks/runtime.py</path>
      <content><![CDATA[from __future__ import annotations

import os
from dash import Input, Output, State, no_update  # noqa: F401
from fum_rt.frontend.controllers.runtime_controller import (
    build_phase_update,
    update_phase_json,
    queue_load_engram,
    parse_engram_events_for_message,
)
from fum_rt.frontend.utilities.tail import tail_jsonl_bytes


def register_runtime_callbacks(app, default_profile):
    """
    Runtime-level controls:
      - Apply phase/runtime tuning -> phase.json
      - Queue load_engram into phase.json
      - Surface engram load events from events.jsonl
    """

    @app.callback(
        Output("phase-status", "children"),
        Input("apply-phase", "n_clicks"),
        State("run-dir", "value"),
        State("phase", "value"),
        State("rc-speak-z", "value"),
        State("rc-speak-hysteresis", "value"),
        State("rc-speak-cooldown", "value"),
        State("rc-speak-valence", "value"),
        State("rc-walkers", "value"),
        State("rc-hops", "value"),
        State("rc-bundle-size", "value"),
        State("rc-prune-factor", "value"),
        State("rc-threshold", "value"),
        State("rc-lambda-omega", "value"),
        State("rc-candidates", "value"),
        State("rc-novelty-idf-gain", "value"),
        prevent_initial_call=True,
    )
    def on_apply_phase(
        _n,
        run_dir,
        phase,
        s_z,
        s_h,
        s_cd,
        s_vt,
        c_w,
        c_h,
        c_b,
        c_pf,
        c_thr,
        c_lw,
        c_cand,
        s_idf,
    ):
        if not run_dir:
            return "Select a run directory."
        update = build_phase_update(
            default_profile,
            phase,
            s_z,
            s_h,
            s_cd,
            s_vt,
            c_w,
            c_h,
            c_b,
            c_pf,
            c_thr,
            c_lw,
            c_cand,
            s_idf,
        )
        ok = update_phase_json(run_dir, update)
        return "Applied" if ok else "Error writing phase.json"

    @app.callback(
        Output("phase-status", "children", allow_duplicate=True),
        Input("rc-load-engram-btn", "n_clicks"),
        State("run-dir", "value"),
        State("rc-load-engram-path", "value"),
        State("rc-load-engram-input", "value"),
        prevent_initial_call=True,
    )
    def on_load_engram_now(_n, run_dir, path, path_text):
        rd = (run_dir or "").strip()
        if not rd:
            return "Select a run directory."
        p = ((path or path_text) or "").strip()
        if not p:
            return "Enter engram path."
        ok, norm = queue_load_engram(rd, p)
        return f"Queued load engram: {norm}" if ok else "Error writing phase.json"

    @app.callback(
        Output("phase-status", "children", allow_duplicate=True),
        Input("poll", "n_intervals"),
        State("run-dir", "value"),
        prevent_initial_call=True,
    )
    def notify_engram_events(_n, run_dir):
        rd = (run_dir or "").strip()
        if not rd:
            return no_update

        # UI responsiveness guard:
        # - By default we avoid any file IO here (large events.jsonl can be 100s of MB).
        # - Opt-in tailing only when DASH_ENGRAM_EVENT_TAIL is explicitly enabled.
        try:
            _disable_io = str(os.getenv("DASH_DISABLE_FILE_IO", "1")).strip().lower() in ("1", "true", "yes", "on")
        except Exception:
            _disable_io = True
        try:
            _engram_tail_on = str(os.getenv("DASH_ENGRAM_EVENT_TAIL", "0")).strip().lower() in ("1", "true", "yes", "on")
        except Exception:
            _engram_tail_on = False
        if _disable_io and not _engram_tail_on:
            return no_update

        state = getattr(notify_engram_events, "_state", None)
        if state is None or state.get("run_dir") != rd:
            state = {"run_dir": rd, "events_size": 0}
            setattr(notify_engram_events, "_state", state)

        ev_path = os.path.join(rd, "events.jsonl")
        recs, new_size = tail_jsonl_bytes(ev_path, state["events_size"])
        state["events_size"] = new_size
        msg = parse_engram_events_for_message(recs)
        return msg if msg else no_update]]></content>
    </file>
    <file>
      <path>callbacks/workspace.py</path>
      <content><![CDATA[from __future__ import annotations

from typing import List
from dash import Input, Output, State, no_update  # noqa: F401 (bound by Dash at runtime)
from fum_rt.frontend.utilities.fs_utils import list_runs


def register_workspace_callbacks(app, runs_root: str, manager):
    """
    Workspace-level callbacks:
      - Refresh run list (options + default selection)
      - Use current managed run
      - Use latest run under a root
    """

    @app.callback(
        Output("run-dir", "options", allow_duplicate=True),
        Output("run-dir", "value", allow_duplicate=True),
        Input("refresh-runs", "n_clicks"),
        State("runs-root", "value"),
        prevent_initial_call=True,
    )
    def on_refresh_runs(_n, root):
        root = root or runs_root
        opts = [{"label": p, "value": p} for p in list_runs(root)]
        val = opts[0]["value"] if opts else ""
        return opts, val

    @app.callback(
        Output("run-dir", "value", allow_duplicate=True),
        Input("use-current-run", "n_clicks"),
        prevent_initial_call=True,
    )
    def on_use_current(_n):
        return manager.current_run_dir or no_update

    @app.callback(
        Output("run-dir", "value", allow_duplicate=True),
        Input("use-latest-run", "n_clicks"),
        State("runs-root", "value"),
        prevent_initial_call=True,
    )
    def on_use_latest(_n, root):
        r = root or runs_root
        rs = list_runs(r)
        return rs[0] if rs else no_update

    # Sync runs-root dropdown -> text input and refresh run list
    @app.callback(
        Output("runs-root", "value"),
        Output("run-dir", "options", allow_duplicate=True),
        Output("run-dir", "value", allow_duplicate=True),
        Input("runs-root-select", "value"),
        prevent_initial_call=True,
    )
    def on_runs_root_select(val):
        r = (val or "").strip()
        if not r:
            return no_update, no_update, no_update
        opts = [{"label": p, "value": p} for p in list_runs(r)]
        v = opts[0]["value"] if opts else ""
        return r, opts, v]]></content>
    </file>
    <file>
      <path>components/charts.py</path>
      <content><![CDATA[from __future__ import annotations

from dash import html
from fum_rt.frontend.components.widgets.graph import graph


def charts_card():
    """
    Charts card composed from graph primitives (widgets).
    IDs preserved to match existing callbacks in fum_live.py.
    """
    return html.Div(
        [
            graph("fig-dashboard", height=420),
            graph("fig-discovery", height=320),
        ],
        className="card",
    )]]></content>
    </file>
    <file>
      <path>components/chat.py</path>
      <content><![CDATA[from __future__ import annotations

from dash import html, dcc


def chat_card():
    """
    Chat panel with log view, filter, input, and send button.
    IDs preserved to match existing callbacks in fum_live.py.
    """
    return html.Div(
        [
            html.H4("Chat"),
            html.Pre(
                id="chat-view",
                style={
                    "height": "220px",
                    "overflowY": "auto",
                    "overflowX": "hidden",
                    "backgroundColor": "#0f141a",
                    "color": "#e0e6ee",
                    "padding": "8px",
                    "whiteSpace": "pre-wrap",
                    "wordBreak": "break-word",
                    "overflowWrap": "anywhere",
                    "hyphens": "none",
                    "border": "1px solid #1d2733",
                    "borderRadius": "8px",
                },
            ),
            html.Div(
                [
                    html.Label("Chat filter"),
                    dcc.RadioItems(
                        id="chat-filter",
                        options=[
                            {"label": "All Outputs", "value": "all"},
                            {"label": "'say' Macro Only", "value": "say"},
                            {"label": "Self-Speak (Spike-Gated)", "value": "spike"},
                        ],
                        value="all",
                        labelStyle={"display": "inline-block", "marginRight": "10px"},
                    ),
                ],
                className="tight",
            ),
            html.Div(
                [
                    dcc.Input(
                        id="chat-input",
                        type="text",
                        placeholder="Type a message and click Send",
                        style={"width": "80%"},
                    ),
                    html.Button("Send", id="chat-send", n_clicks=0),
                ],
                className="row tight",
            ),
            html.Pre(id="chat-status", style={"fontSize": "12px"}),
        ],
        className="card",
    )]]></content>
    </file>
    <file>
      <path>components/feed.py</path>
      <content><![CDATA[from __future__ import annotations

from typing import List, Dict
from dash import html, dcc
from fum_rt.frontend.components.widgets.file_picker import file_picker


def feed_card(data_files_options: List[Dict[str, str]]):
    """
    Feed stdin (optional) card.
    IDs preserved to match existing callbacks.
    """
    return html.Div(
        [
            html.H4("Feed stdin (optional)"),
            file_picker(prefix="feed-file", title="Select feed file", initial="", width="100%"),
            dcc.Dropdown(
                id="feed-path",
                options=data_files_options,
                placeholder="select feed file...",
                style={"width": "100%", "display": "none"},
            ),
            dcc.Input(
                id="feed-rate",
                type="number",
                value=20,
                step=1,
                style={"width": "120px", "marginTop": "6px"},
            ),
            html.Div(
                [
                    html.Button("Start Feed", id="feed-start", n_clicks=0, className="btn-ok"),
                    html.Button("Stop Feed", id="feed-stop", n_clicks=0, className="btn-danger"),
                ],
                className="row tight",
            ),
            html.Pre(id="send-status", style={"fontSize": "12px"}),
        ],
        className="card",
    )]]></content>
    </file>
    <file>
      <path>components/layout.py</path>
      <content><![CDATA[from __future__ import annotations

import os
from typing import Any, Dict, List

from dash import html, dcc

from fum_rt.frontend.components.workspace import workspace_card
from fum_rt.frontend.components.runtime_controls import runtime_controls_card
from fum_rt.frontend.components.feed import feed_card
from fum_rt.frontend.components.run_config import run_config_card
from fum_rt.frontend.components.charts import charts_card
from fum_rt.frontend.components.chat import chat_card

__all__ = ["build_layout"]


def build_layout(
    runs_root: str,
    runs: List[str],
    default_run: str,
    repo_root: str,  # kept for legacy signature; not used
    profiles_dir: str,  # kept for legacy signature; not used
    default_profile: Dict[str, Any],
    domain_options: List[Dict[str, str]],
    data_files_options: List[Dict[str, str]],
    profile_options: List[Dict[str, str]],
) -> html.Div:
    """
    Construct the full dashboard layout (no callbacks).
    Wrapper around modular cards to preserve legacy build_layout signature.
    IDs preserved to match existing callbacks in fum_live.
    """
    poll_ms_env = os.getenv("DASH_POLL_MS", "1200")
    try:
        poll_ms_val = int(poll_ms_env) if poll_ms_env.strip() != "" else 1200
    except ValueError:
        poll_ms_val = 1200
    poll_interval = max(250, poll_ms_val)
    poll_disabled = poll_ms_val <= 0

    return html.Div(
        [
            html.H3("FUM Live Dashboard (external control)"),
            html.Div(
                [
                    html.Div(
                        [
                            workspace_card(runs_root, runs, default_run),
                            runtime_controls_card(default_profile),
                            feed_card(data_files_options),
                        ],
                        style={"minWidth": "320px", "display": "grid", "gap": "16px"},
                    ),
                    html.Div(
                        [
                            run_config_card(default_profile, domain_options, profile_options),
                            charts_card(),
                            chat_card(),
                        ],
                        style={"minWidth": "400px", "display": "grid", "gap": "16px"},
                    ),
                ],
                className="grid",
            ),
            dcc.Interval(id="poll", interval=poll_interval, n_intervals=0, disabled=poll_disabled),
            dcc.Store(id="chat-state"),
            dcc.Store(id="ui-state"),
        ],
        style={"padding": "10px"},
    )
]]></content>
    </file>
    <file>
      <path>components/perf.py</path>
      <content><![CDATA[from __future__ import annotations

from dash import html, dcc


def perf_card():
    """
    UI Performance card (no environment variables required).
    Publishes settings into dcc.Store(id="ui-state") via callbacks/perf.register_perf_callbacks.
    """
    return html.Div(
        [
            html.H4("UI Performance"),
            html.Div(
                [
                    html.Div(
                        [
                            html.Label("Charts: HTTP snapshot only"),
                            dcc.Checklist(
                                id="ui-charts-http",
                                options=[{"label": " On", "value": "on"}],
                                value=[],  # default OFF — falls back to bounded file tails if HTTP not ready
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Update interval (ms)"),
                            dcc.Input(id="ui-update-ms", type="number", value=800, min=250, step=50),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Points per series cap"),
                            dcc.Input(id="ui-points-cap", type="number", value=1200, min=100, step=50),
                        ]
                    ),
                ],
                className="row",
            ),
            html.Div(
                [
                    html.Div(
                        [
                            html.Label("Series count cap"),
                            dcc.Input(id="ui-series-cap", type="number", value=6, min=1, step=1),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Status URL"),
                            dcc.Input(
                                id="ui-status-url",
                                type="text",
                                value="http://127.0.0.1:8787/status/snapshot",
                                style={"width": "100%"},
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Status timeout (s)"),
                            dcc.Input(id="ui-status-timeout", type="number", value=0.2, min=0.05, step=0.05),
                        ]
                    ),
                ],
                className="row",
            ),
            html.Div(
                [
                    html.Div(
                        [
                            html.Label("Tail Chat file"),
                            dcc.Checklist(id="ui-tail-chat", options=[{"label": " On", "value": "on"}], value=[]),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Tail Launcher log"),
                            dcc.Checklist(id="ui-tail-launch", options=[{"label": " On", "value": "on"}], value=[]),
                        ]
                    ),
                ],
                className="row",
            ),
            html.Small(
                "Settings apply immediately; no env vars or restart required.",
                style={"color": "#8699ac"},
            ),
        ],
        className="card",
    )


__all__ = ["perf_card"]]]></content>
    </file>
    <file>
      <path>components/run_config.py</path>
      <content><![CDATA[from __future__ import annotations

from typing import Dict, Any, List
from dash import html

# Modular sections (IDs preserved exactly as before)
from fum_rt.frontend.components.run_config import (
    section_core_params,
    section_modes,
    section_structure_traversal,
    section_stimulus,
    section_speak_b1,
    section_viz_logs_checkpoints,
    section_profile_io,
    section_process_actions,
)


def run_config_card(
    default_profile: Dict[str, Any],
    domain_options: List[Dict[str, str]],
    profile_options: List[Dict[str, str]],
):
    """
    Run configuration & process card (modular assembly).
    All element IDs preserved to match existing callbacks.
    """
    return html.Div(
        [
            html.H4("Run configuration & process"),
            # Sections assembled in a clear, readable order
            section_core_params(default_profile, domain_options),
            section_modes(default_profile),
            section_structure_traversal(default_profile),
            section_stimulus(default_profile),
            section_speak_b1(default_profile),
            section_viz_logs_checkpoints(default_profile),
            section_profile_io(profile_options),
            section_process_actions(),
        ],
        className="card",
    )]]></content>
    </file>
    <file>
      <path>components/run_config/__init__.py</path>
      <content><![CDATA[from __future__ import annotations

"""
Run Config components package.

Exports:
- run_config_card(): assembled card (IDs preserved)
- section_* helpers from .sections for fine-grained composition
"""

from typing import Dict, Any, List
from dash import html

from .sections import (
    section_core_params,
    section_modes,
    section_structure_traversal,
    section_stimulus,
    section_speak_b1,
    section_viz_logs_checkpoints,
    section_profile_io,
    section_process_actions,
)


def run_config_card(
    default_profile: Dict[str, Any],
    domain_options: List[Dict[str, str]],
    profile_options: List[Dict[str, str]],
):
    """
    Run configuration & process card (modular assembly).
    All element IDs preserved to match existing callbacks.
    """
    return html.Div(
        [
            html.H4("Run configuration & process"),
            section_core_params(default_profile, domain_options),
            section_modes(default_profile),
            section_structure_traversal(default_profile),
            section_stimulus(default_profile),
            section_speak_b1(default_profile),
            section_viz_logs_checkpoints(default_profile),
            section_profile_io(profile_options),
            section_process_actions(),
        ],
        className="card",
    )


__all__ = [
    "run_config_card",
    "section_core_params",
    "section_modes",
    "section_structure_traversal",
    "section_stimulus",
    "section_speak_b1",
    "section_viz_logs_checkpoints",
    "section_profile_io",
    "section_process_actions",
]]]></content>
    </file>
    <file>
      <path>components/run_config/sections.py</path>
      <content><![CDATA[from __future__ import annotations

"""
Run Config modular sections.

Purpose:
- Break the large run_config_card into readable, maintainable sections
- Preserve ALL existing element IDs to avoid breaking callbacks
- No new callbacks introduced; purely structural/UX refactor

Sections:
- Core (neurons, k, hz, domain)
- Modes (use_time_dynamics, sparse_mode)
- Structure & Traversal (threshold, lambda_omega, candidates, walkers, hops, bundle_size, prune_factor, status_interval)
- Stimulus (stim_* fields)
- Speak / B1 (speak_* and b1_* fields)
- Viz / Logs / Checkpoints
- Profile I/O (profile-name, save/load, file picker + status)
- Process Actions (start/resume/stop + status + log)

Author: Justin K. Lietz
"""

from typing import Dict, Any, List
from dash import html, dcc

from fum_rt.frontend.components.widgets.file_picker import file_picker


def _num(id_: str, label: str, value: Any, step: float | int, min: Any | None = None, max: Any | None = None) -> html.Div:
    """Consistent number input with label. ID preserved."""
    return html.Div(
        [
            html.Label(label),
            dcc.Input(id=id_, type="number", value=value, step=step, min=min, max=max),
        ]
    )


def _toggle(id_: str, label: str, on: bool) -> html.Div:
    """Consistent On/Off checklist with label. ID preserved."""
    return html.Div(
        [
            html.Label(label),
            dcc.Checklist(id=id_, options=[{"label": " On", "value": "on"}], value=["on"] if on else []),
        ]
    )


def section_core_params(default_profile: Dict[str, Any], domain_options: List[Dict[str, str]]) -> html.Div:
    return html.Div(
        [
            html.H5("Core", style={"margin": "6px 0 4px 0", "opacity": 0.9}),
            html.Div(
                [
                    _num("cfg-neurons", "Neurons", default_profile["neurons"], step=1, min=1),
                    _num("cfg-k", "k", default_profile["k"], step=1, min=1),
                    _num("cfg-hz", "Hz", default_profile["hz"], step=1, min=1),
                    html.Div(
                        [
                            html.Label("Domain"),
                            dcc.Dropdown(id="cfg-domain", options=domain_options, value=default_profile["domain"]),
                        ]
                    ),
                ],
                className="row",
            ),
        ],
        className="section",
    )


def section_modes(default_profile: Dict[str, Any]) -> html.Div:
    return html.Div(
        [
            html.H5("Modes", style={"margin": "6px 0 4px 0", "opacity": 0.9}),
            html.Div(
                [
                    _toggle("cfg-use-time-dynamics", "Use time dynamics", bool(default_profile["use_time_dynamics"])),
                    _toggle("cfg-sparse-mode", "Sparse mode", bool(default_profile["sparse_mode"])),
                ],
                className="row",
            ),
        ],
        className="section",
    )


def section_structure_traversal(default_profile: Dict[str, Any]) -> html.Div:
    return html.Div(
        [
            html.H5("Structure & traversal", style={"margin": "6px 0 4px 0", "opacity": 0.9}),
            html.Div(
                [
                    _num("cfg-threshold", "Threshold", default_profile["threshold"], step=0.01, min=0),
                    _num("cfg-lambda-omega", "Lambda omega", default_profile["lambda_omega"], step=0.01, min=0),
                    _num("cfg-candidates", "Candidates", default_profile["candidates"], step=1, min=1),
                    _num("cfg-walkers", "Walkers", default_profile["walkers"], step=1, min=1),
                    _num("cfg-hops", "Hops", default_profile["hops"], step=1, min=1),
                    _num("cfg-bundle-size", "Bundle size", default_profile["bundle_size"], step=1, min=1),
                    _num("cfg-prune-factor", "Prune factor", default_profile["prune_factor"], step=0.01, min=0, max=1),
                    _num("cfg-status-interval", "Status interval", default_profile["status_interval"], step=1, min=1),
                ],
                className="row",
            ),
        ],
        className="section",
    )


def section_stimulus(default_profile: Dict[str, Any]) -> html.Div:
    return html.Div(
        [
            html.H5("Stimulus", style={"margin": "6px 0 4px 0", "opacity": 0.9}),
            html.Div(
                [
                    _num("cfg-stim-group-size", "Group size", default_profile["stim_group_size"], step=1, min=1),
                    _num("cfg-stim-amp", "Amp", default_profile["stim_amp"], step=0.01, min=0),
                    _num("cfg-stim-decay", "Decay", default_profile["stim_decay"], step=0.01, min=0, max=1),
                    _num("cfg-stim-max-symbols", "Max symbols", default_profile["stim_max_symbols"], step=1, min=1),
                ],
                className="row",
            ),
        ],
        className="section",
    )


def section_speak_b1(default_profile: Dict[str, Any]) -> html.Div:
    return html.Div(
        [
            html.H5("Speak / B1 spike detector", style={"margin": "6px 0 4px 0", "opacity": 0.9}),
            html.Div(
                [
                    _toggle("cfg-speak-auto", "Speak auto", bool(default_profile["speak_auto"])),
                    _num("cfg-speak-z", "Speak z", default_profile["speak_z"], step=0.1, min=0),
                    _num("cfg-speak-hysteresis", "Hysteresis", default_profile["speak_hysteresis"], step=0.1, min=0),
                    _num("cfg-speak-cooldown-ticks", "Cooldown (ticks)", default_profile["speak_cooldown_ticks"], step=1, min=1),
                    _num("cfg-speak-valence-thresh", "Valence thresh", default_profile["speak_valence_thresh"], step=0.01, min=0, max=1),
                    _num("cfg-b1-half-life-ticks", "B1 half-life (ticks)", default_profile["b1_half_life_ticks"], step=1, min=1),
                ],
                className="row",
            ),
        ],
        className="section",
    )


def section_viz_logs_checkpoints(default_profile: Dict[str, Any]) -> html.Div:
    return html.Div(
        [
            html.H5("Viz / Logs / Checkpoints", style={"margin": "6px 0 4px 0", "opacity": 0.9}),
            html.Div(
                [
                    _num("cfg-viz-every", "viz_every", default_profile["viz_every"], step=1, min=0),
                    _num("cfg-log-every", "log_every", default_profile["log_every"], step=1, min=1),
                    _num("cfg-checkpoint-every", "checkpoint_every", default_profile["checkpoint_every"], step=1, min=0),
                    _num("cfg-checkpoint-keep", "checkpoint_keep", default_profile["checkpoint_keep"], step=1, min=0),
                    _num("cfg-duration", "duration (s)", default_profile["duration"], step=1, min=0),
                ],
                className="row",
            ),
        ],
        className="section",
    )


def section_profile_io(profile_options: List[Dict[str, str]]) -> html.Div:
    """Save/Load profile, with file picker; includes profile-save-status."""
    return html.Div(
        [
            html.H5("Profile I/O", style={"margin": "6px 0 4px 0", "opacity": 0.9}),
            html.Div(
                [
                    dcc.Input(id="profile-name", type="text", placeholder="profile name", style={"width": "200px"}),
                    html.Button("Save Profile", id="save-profile", n_clicks=0),
                    file_picker(prefix="profile-file", title="Select profile (.json)", initial="", width="50%"),
                    dcc.Dropdown(
                        id="profile-path",
                        options=profile_options,
                        placeholder="load profile",
                        style={"width": "50%", "display": "none"},
                    ),
                    html.Button("Load", id="load-profile", n_clicks=0),
                ],
                className="row tight",
            ),
            html.Pre(id="profile-save-status", style={"fontSize": "12px", "whiteSpace": "pre-wrap"}),
        ],
        className="section",
    )


def section_process_actions() -> html.Div:
    """Start/Resume/Stop + proc-status + launcher log."""
    return html.Div(
        [
            html.H5("Process actions", style={"margin": "6px 0 4px 0", "opacity": 0.9}),
            html.Div(
                [
                    html.Button("Start New Run", id="start-run", n_clicks=0, className="btn-ok"),
                    html.Button("Resume Selected Run", id="resume-run", n_clicks=0),
                    html.Button("Stop Managed Run", id="stop-run", n_clicks=0, className="btn-danger"),
                ],
                className="row tight",
            ),
            html.Pre(id="proc-status", style={"fontSize": "12px", "whiteSpace": "pre-wrap"}),
            html.Button("Show Launcher Log", id="show-log", n_clicks=0),
            html.Pre(id="launch-log", style={"fontSize": "12px", "maxHeight": "240px", "overflowY": "auto"}),
        ],
        className="section",
    )]]></content>
    </file>
    <file>
      <path>components/runtime_controls.py</path>
      <content><![CDATA[from __future__ import annotations

from typing import Dict, Any
from dash import html, dcc
from fum_rt.frontend.components.widgets.file_picker import file_picker


def runtime_controls_card(default_profile: Dict[str, Any]):
    """
    Runtime tuning + load-engram controls.
    IDs preserved to match existing callbacks in fum_live.
    """
    return html.Div(
        [
            html.H4("Runtime Controls"),
            html.Label("Phase"),
            dcc.Slider(
                id="phase",
                min=0,
                max=4,
                step=1,
                value=0,
                marks={i: str(i) for i in range(5)},
            ),
            html.Div(
                [
                    html.Div(
                        [
                            html.Label("Speak z"),
                            dcc.Input(
                                id="rc-speak-z",
                                type="number",
                                value=default_profile["speak_z"],
                                step=0.1,
                                min=0,
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Hysteresis"),
                            dcc.Input(
                                id="rc-speak-hysteresis",
                                type="number",
                                value=default_profile["speak_hysteresis"],
                                step=0.1,
                                min=0,
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Cooldown (ticks)"),
                            dcc.Input(
                                id="rc-speak-cooldown",
                                type="number",
                                value=default_profile["speak_cooldown_ticks"],
                                step=1,
                                min=1,
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Valence thresh"),
                            dcc.Input(
                                id="rc-speak-valence",
                                type="number",
                                value=default_profile["speak_valence_thresh"],
                                step=0.01,
                                min=0,
                                max=1,
                            ),
                        ]
                    ),
                ],
                className="row tight",
            ),
            html.Div(
                [
                    html.Div(
                        [
                            html.Label("Walkers"),
                            dcc.Input(
                                id="rc-walkers",
                                type="number",
                                value=default_profile["walkers"],
                                step=1,
                                min=1,
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Hops"),
                            dcc.Input(
                                id="rc-hops",
                                type="number",
                                value=default_profile["hops"],
                                step=1,
                                min=1,
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Bundle size"),
                            dcc.Input(
                                id="rc-bundle-size",
                                type="number",
                                value=default_profile["bundle_size"],
                                step=1,
                                min=1,
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Prune factor"),
                            dcc.Input(
                                id="rc-prune-factor",
                                type="number",
                                value=default_profile["prune_factor"],
                                step=0.01,
                                min=0,
                                max=1,
                            ),
                        ]
                    ),
                ],
                className="row tight",
            ),
            html.Div(
                [
                    html.Div(
                        [
                            html.Label("Threshold"),
                            dcc.Input(
                                id="rc-threshold",
                                type="number",
                                value=default_profile.get("threshold", 0.15),
                                step=0.01,
                                min=0,
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Lambda omega"),
                            dcc.Input(
                                id="rc-lambda-omega",
                                type="number",
                                value=default_profile.get("lambda_omega", 0.10),
                                step=0.01,
                                min=0,
                            ),
                        ]
                    ),
                    html.Div(
                        [
                            html.Label("Candidates"),
                            dcc.Input(
                                id="rc-candidates",
                                type="number",
                                value=default_profile.get("candidates", 64),
                                step=1,
                                min=1,
                            ),
                        ]
                    ),
                ],
                className="row tight",
            ),
            html.Div(
                [
                    html.Label("SIE novelty IDF gain"),
                    dcc.Input(
                        id="rc-novelty-idf-gain",
                        type="number",
                        value=1.0,
                        step=0.05,
                        min=0,
                    ),
                ],
                className="tight",
            ),
            html.Div(
                [
                    html.Button(
                        "Apply Runtime Settings",
                        id="apply-phase",
                        n_clicks=0,
                        className="btn-ok",
                    )
                ],
                className="tight",
            ),
            html.Pre(id="phase-status", style={"fontSize": "12px"}),
            html.Label("Load Engram (runtime, into selected Run)"),
            file_picker(prefix="engram-file", title="Select engram (.h5/.npz)", initial="", width="100%"),
            dcc.Input(
                id="rc-load-engram-input",
                type="text",
                placeholder="path to .h5/.npz (abs or under runs)",
                style={"width": "100%", "marginTop": "4px"},
            ),
            dcc.Dropdown(
                id="rc-load-engram-path",
                placeholder="select from runs...",
                style={"width": "100%", "marginTop": "4px", "display": "none"},
            ),
            html.Button(
                "Load Engram Now",
                id="rc-load-engram-btn",
                n_clicks=0,
                className="tight",
            ),
        ],
        className="card",
    )]]></content>
    </file>
    <file>
      <path>components/widgets/file_breadcrumbs.py</path>
      <content><![CDATA[from __future__ import annotations

"""
Breadcrumbs widget for the File Picker component.

Pure UI builder. No IO, no state. Pattern-matching friendly IDs.
"""

from dash import html


def breadcrumbs(prefix: str, base: str | None, selected: str | None):
    """
    Build breadcrumbs from base (root) to selected directory.

    Args:
      prefix: file picker instance prefix
      base: absolute root directory
      selected: absolute selected directory (within base)
    """
    try:
        base = (base or "").strip()
        selected = (selected or "").strip()
        if not base:
            return []
        root_label = base.rstrip("/").split("/")[-1] or base
        out = [
            html.Button(
                root_label,
                id={"role": f"{prefix}-crumb", "path": base},
                n_clicks=0,
                style={"background": "transparent", "border": "none", "color": "#9ab8d1", "cursor": "pointer", "padding": "2px 4px"},
            )
        ]
        if selected and selected != base:
            # Render each path segment from base -> selected
            rel = selected[len(base) + 1 :] if selected.startswith(base + "/") else selected
            for part in [p for p in rel.split("/") if p]:
                base = f"{base}/{part}"
                out.append(html.Span("›", style={"opacity": 0.6, "padding": "0 2px"}))
                out.append(
                    html.Button(
                        part,
                        id={"role": f"{prefix}-crumb", "path": base},
                        n_clicks=0,
                        style={"background": "transparent", "border": "none", "color": "#9ab8d1", "cursor": "pointer", "padding": "2px 4px"},
                    )
                )
        return out
    except Exception:
        return []]]></content>
    </file>
    <file>
      <path>components/widgets/file_picker.py</path>
      <content><![CDATA[from __future__ import annotations

"""
Reusable, themed file-picker component for Dash (no heavy scans, lazy-only).
- Compact display: shows selected basename + a "Choose file" button
- Modal overlay: navigable file tree rooted at a configured directory
- Bounded IO: lists one directory at a time; no recursive scans
- Integrates with existing callbacks via a target component id to receive the chosen path

Usage:
  In a component:
    from fum_rt.frontend.components.widgets.file_picker import file_picker

    # Place the compact picker UI where the dropdown used to be
    file_picker(prefix="feed", title="Select feed file", initial="", width="100%")

  In app initialization:
    from fum_rt.frontend.callbacks.file_picker import register_file_picker_instance
    register_file_picker_instance(
        app,
        prefix="feed",
        root=data_root_abs,
        exts=[".txt", ".jsonl", ".json", ".csv"],
        target_id="feed-path",  # the component id that should receive the chosen path (value property)
    )

IDs produced (all prefixed):
  - {prefix}-open-btn
  - {prefix}-modal (overlay container)
  - {prefix}-root (dcc.Store of absolute root)
  - {prefix}-cwd (dcc.Store of current working dir)
  - {prefix}-exts (dcc.Store of allowed extensions list or [])
  - {prefix}-dirs (dcc.Dropdown listing folders in cwd)
  - {prefix}-files (dcc.Dropdown listing files in cwd)
  - {prefix}-up-btn, {prefix}-root-btn
  - {prefix}-confirm-btn, {prefix}-cancel-btn
  - {prefix}-selected-label (compact label of chosen file)
  - {prefix}-selected-path (dcc.Store holding absolute path)
"""

from dash import html, dcc


def _modal_styles() -> dict:
    # Fixed viewport overlay that does not affect background layout.
    # Avoid 100vw/100vh which can introduce horizontal scrollbars and trigger reflow.
    # Use explicit edges for broad browser support (instead of inset).
    return {
        "position": "fixed",
        "top": 0,
        "right": 0,
        "bottom": 0,
        "left": 0,
        "backgroundColor": "rgba(10,14,19,0.66)",
        "display": "none",  # toggled by callbacks
        "alignItems": "center",
        "justifyContent": "center",
        "zIndex": 20000,  # above react-select menus (9999)
        "pointerEvents": "auto",
        "contain": "layout paint",  # isolate overlay layout/paint so background is unaffected
        "isolation": "isolate",     # create a new stacking context for safety
    }


def _panel_styles() -> dict:
    return {
        "position": "relative",
        "backgroundColor": "#0f141a",
        "color": "#cfd7e3",
        "border": "1px solid #233140",
        "borderRadius": "8px",
        "minWidth": "560px",
        "maxWidth": "86vw",
        "maxHeight": "86vh",
        "display": "grid",
        "gridTemplateRows": "auto auto 1fr auto",
        "gap": "8px",
        "padding": "12px",
        "boxShadow": "0 4px 16px rgba(0,0,0,0.4)",
        "overflow": "hidden",
        "zIndex": 20001,              # ensure panel stacks above overlay
        "pointerEvents": "auto",      # interactive; background remains inert
        "contain": "layout paint",    # isolate panel's layout/paint
        "overscrollBehavior": "contain",  # prevent body scroll chaining
    }


def _row_styles() -> dict:
    return {"display": "flex", "gap": "8px", "alignItems": "center", "justifyContent": "flex-start"}


def file_picker(prefix: str, title: str, initial: str = "", width: str = "100%") -> html.Div:
    """
    Build the compact file-picker UI with modal overlay.

    Args:
      prefix: unique prefix for component IDs
      title: title to show in the modal
      initial: initial selected path (optional)
      width: width style for compact strip

    Returns:
      html.Div node
    """
    return html.Div(
        [
            # Compact strip: selected filename + button
            html.Div(
                [
                    html.Span(
                        "Selected: ",
                        style={"opacity": 0.8, "marginRight": "6px", "fontSize": "13px"},
                    ),
                    html.Span(
                        initial or "(none)",
                        id=f"{prefix}-selected-label",
                        style={
                            "fontWeight": 500,
                            "fontSize": "13px",
                            "maxWidth": "60%",
                            "overflow": "hidden",
                            "textOverflow": "ellipsis",
                            "whiteSpace": "nowrap",
                            "display": "inline-block",
                            "verticalAlign": "middle",
                        },
                    ),
                    html.Button(
                        "Choose file",
                        id=f"{prefix}-open-btn",
                        n_clicks=0,
                        className="btn-ok",
                    ),
                ],
                style={
                    "display": "flex",
                    "alignItems": "center",
                    "width": width,
                    "gap": "8px",
                    "flexWrap": "wrap",
                    "justifyContent": "flex-start",
                    "background": "var(--panel2)",
                    "border": "1px solid var(--border)",
                    "borderRadius": "8px",
                    "padding": "6px 8px",
                    "minHeight": "36px"
                },
            ),
            # Persistent stores for this instance
            dcc.Store(id=f"{prefix}-root"),
            dcc.Store(id=f"{prefix}-cwd"),
            dcc.Store(id=f"{prefix}-exts"),
            dcc.Store(id=f"{prefix}-selected-path", data=initial),
            dcc.Store(id=f"{prefix}-file-sel"),
            dcc.Store(id=f"{prefix}-dir-sel"),
            dcc.Store(id=f"{prefix}-selected-dir"),
            dcc.Store(id=f"{prefix}-tree-store"),
            dcc.Store(id=f"{prefix}-last-action"),
            # Modal overlay
            html.Div(
                [
                    html.Div(
                        [
                            # Title bar
                            html.Div(
                                [
                                    html.H4(title, style={"margin": "0", "fontSize": "16px"}),
                                    html.Button("×", id=f"{prefix}-cancel-btn", n_clicks=0, title="Close"),
                                ],
                                style={"display": "flex", "justifyContent": "space-between", "alignItems": "center"},
                            ),
                            # Toolbar
                            html.Div(
                                [
                                    html.Button("Root", id=f"{prefix}-root-btn", n_clicks=0),
                                    html.Button("Up", id=f"{prefix}-up-btn", n_clicks=0),
                                    html.Div(id=f"{prefix}-cwd-label", style={"marginLeft": "10px", "opacity": 0.8}),
                                ],
                                style=_row_styles(),
                            ),
                            # Breadcrumbs
                            html.Div(
                                id=f"{prefix}-crumbs",
                                style={"display": "flex", "gap": "6px", "flexWrap": "wrap", "fontSize": "12px", "opacity": 0.9},
                            ),
                            # Body: single explorer (folders + files)
                            html.Div(
                                [
                                    html.Div(
                                        [
                                            html.Label("Explorer"),
                                            html.Div(
                                                id=f"{prefix}-dirs-list",
                                                style={
                                                    "border": "1px solid var(--border)",
                                                    "borderRadius": "8px",
                                                    "background": "var(--panel2)",
                                                    "maxHeight": "60vh",
                                                    "overflowY": "auto",
                                                    "padding": "4px",
                                                },
                                            ),
                                            dcc.Dropdown(
                                                id=f"{prefix}-dirs",
                                                options=[],
                                                placeholder="(no subfolders)",
                                                clearable=False,
                                                style={"display": "none"},
                                            ),
                                            html.Button("Open folder", id=f"{prefix}-open-dir-btn", n_clicks=0, style={"display": "none"}),
                                        ],
                                        style={"display": "grid", "gap": "6px"},
                                    ),
                                ],
                                style={
                                    "overflow": "auto",
                                    "maxHeight": "60vh",
                                },
                            ),
                            # Action row
                            html.Div(
                                [
                                    html.Button("Confirm", id=f"{prefix}-confirm-btn", n_clicks=0, className="btn-ok"),
                                    html.Div(id=f"{prefix}-status", style={"marginLeft": "12px", "opacity": 0.8, "fontSize": "12px"}),
                                ],
                                style=_row_styles(),
                            ),
                        ],
                        style=_panel_styles(),
                    )
                ],
                id=f"{prefix}-modal",
                style=_modal_styles(),
            ),
        ],
    )]]></content>
    </file>
    <file>
      <path>components/widgets/file_tree.py</path>
      <content><![CDATA[from __future__ import annotations

"""
File tree row widgets for the File Picker component.

Pure UI builders (no IO, no state). IDs are pattern-matching friendly.
"""

from dash import html


def dir_row(prefix: str, path: str, name: str, depth: int, expanded: bool, is_selected: bool):
    """
    Build a single directory row with chevron and folder icon.

    Args:
      prefix: file picker instance prefix
      path: absolute directory path this row represents
      name: label to display
      depth: nesting depth for left indent
      expanded: whether the directory is expanded
      is_selected: whether this directory is the currently selected one
    """
    chevron = "▾" if expanded else "▸"
    icon = "📁"
    return html.Div(
        html.Button(
            [
                html.Span(chevron, style={"width": "1em"}),
                html.Span(icon, style={"width": "1.2em"}),
                html.Span(name, style={"overflow": "hidden", "textOverflow": "ellipsis"}),
            ],
            id={"role": f"{prefix}-tree-dir", "path": path},
            n_clicks=0,
            style={
                "display": "flex",
                "alignItems": "center",
                "gap": "6px",
                "padding": "4px 6px",
                "borderRadius": "6px",
                "cursor": "pointer",
                "width": "100%",
                "textAlign": "left",
                "background": "rgba(106,160,194,0.18)" if is_selected else "transparent",
                "border": "1px solid var(--border)" if is_selected else "1px solid rgba(35,49,64,0.0)",
                "marginLeft": f"{depth * 12}px",
            },
        )
    )


def file_row(prefix: str, file_path: str, depth: int, selected: bool):
    """
    Build a single file row with bullet and page icon.

    Args:
      prefix: file picker instance prefix
      file_path: absolute file path this row represents
      depth: nesting depth (aligned as child of its directory)
      selected: whether this file is currently selected
    """
    fname = file_path.split("/")[-1]
    return html.Div(
        html.Button(
            [
                html.Span("•", style={"width": "1em", "opacity": 0.7}),
                html.Span("📄", style={"width": "1.2em"}),
                html.Span(fname, style={"overflow": "hidden", "textOverflow": "ellipsis"}),
            ],
            id={"role": f"{prefix}-file", "path": file_path},
            n_clicks=0,
            style={
                "display": "flex",
                "alignItems": "center",
                "gap": "6px",
                "padding": "4px 6px",
                "borderRadius": "6px",
                "cursor": "pointer",
                "width": "100%",
                "textAlign": "left",
                "background": "rgba(106,160,194,0.18)" if selected else "transparent",
                "border": "1px solid var(--border)" if selected else "1px solid rgba(35,49,64,0.0)",
                "marginLeft": f"{(depth + 1) * 12}px",
            },
        )
    )]]></content>
    </file>
    <file>
      <path>components/widgets/graph.py</path>
      <content><![CDATA[from __future__ import annotations

from dash import dcc


def graph(id: str, height: int = 420, width: str = "100%"):
    """
    Primitive graph widget (lego block).
    Used by higher-level components to compose chart cards.
    """
    return dcc.Graph(id=id, style={"height": f"{int(height)}px", "width": width})]]></content>
    </file>
    <file>
      <path>components/workspace.py</path>
      <content><![CDATA[from __future__ import annotations

import os
from typing import List
from dash import html, dcc


def _runs_root_options(runs_root: str):
    """
    Build candidate runs-root dropdown options:
    - current runs_root
    - ./runs
    - ./runs.bak
    Only include those that exist (abs or relative).
    """
    cand = []
    for p in [runs_root, "runs", "runs.bak"]:
        p = (p or "").strip()
        if not p:
            continue
        # Normalize to absolute if relative exists
        abs_p = p if os.path.isabs(p) else os.path.abspath(p)
        try:
            if os.path.isdir(abs_p) and abs_p not in cand:
                cand.append(abs_p)
        except Exception:
            continue
    if not cand and runs_root:
        cand.append(runs_root)
    return [{"label": s, "value": s} for s in cand]


def workspace_card(runs_root: str, runs: List[str], default_run: str):
    """
    Workspace card with runs root controls and run selector.
    IDs preserved to match existing callbacks.

    Changes:
    - Restores a Runs Root dropdown (runs-root-select) alongside the text input.
      A small sync callback in workspace callbacks should update runs-root when the
      dropdown changes.
    """
    return html.Div(
        [
            html.H4("Workspace"),
            html.Label("Runs root (select)"),
            dcc.Dropdown(
                id="runs-root-select",
                options=_runs_root_options(runs_root),
                value=runs_root,
                placeholder="Select runs root...",
                style={"width": "100%"},
            ),
            html.Label("Runs root (edit)"),
            dcc.Input(id="runs-root", type="text", value=runs_root, style={"width": "100%"}),
            html.Div(
                [
                    html.Button("Refresh Runs", id="refresh-runs", n_clicks=0),
                    html.Button("Use Current Run", id="use-current-run", n_clicks=0),
                    html.Button("Use Latest Run", id="use-latest-run", n_clicks=0),
                ],
                className="row tight",
            ),
            html.Label("Run directory"),
            dcc.Dropdown(
                id="run-dir",
                options=[{"label": p, "value": p} for p in runs],
                value=default_run,
            ),
        ],
        className="card",
    )]]></content>
    </file>
    <file>
      <path>controllers/__init__.py</path>
      <content><![CDATA["""
Controllers for reusable business logic extracted from Dash callbacks.
"""

from .runtime_controller import (
    build_phase_update,
    update_phase_json,
    queue_load_engram,
    parse_engram_events_for_message,
)

__all__ = [
    "build_phase_update",
    "update_phase_json",
    "queue_load_engram",
    "parse_engram_events_for_message",
]]]></content>
    </file>
    <file>
      <path>controllers/charts_controller.py</path>
      <content><![CDATA[from __future__ import annotations

import os
import math
from typing import Tuple, Optional
import plotly.graph_objs as go

from fum_rt.frontend.utilities.tail import tail_jsonl_bytes
from fum_rt.frontend.models.series import SeriesState, append_event, append_say, ffill, extract_tick
from fum_rt.frontend.services.status_client import get_status_snapshot as _get_status


def compute_dashboard_figures(run_dir: str, state: Optional[SeriesState], ui: Optional[dict] = None) -> Tuple[go.Figure, go.Figure, SeriesState]:
    """
    Pure controller for figure construction.
    - Stateless inputs: run_dir, prior state (SeriesState or None)
    - UI dict: optional caps and toggles from in-app controls (no env needed)
    - Returns: (fig_dashboard, fig_discovery, new_state)
    """
    if state is None or getattr(state, "run_dir", None) != run_dir:
        state = SeriesState(run_dir)
    ui = ui or {}

    # Prefer HTTP status snapshot; fallback to cheap file tails if unavailable.
    # Detect truncation/rotation or run restart remains supported via tick/time regression.
    prev_es = getattr(state, "events_size", 0)
    prev_us = getattr(state, "utd_size", 0)
    new_events, esize = [], prev_es
    new_utd, usize = [], prev_us

    snap = None
    try:
        url = None
        timeout_s = None
        try:
            _u = ui.get("status_url") if isinstance(ui, dict) else None
            if isinstance(_u, str) and _u:
                url = _u
        except Exception:
            pass
        try:
            _ts = ui.get("status_timeout") if isinstance(ui, dict) else None
            if _ts is not None:
                timeout_s = float(_ts)
        except Exception:
            pass
        snap = _get_status(url, timeout_s)
    except Exception:
        snap = None

    # Honor UI preference: use HTTP snapshot only when requested; otherwise allow bounded file tails.
    # Default: False (allow file tails) so graphs populate even before ui-state is ready.
    charts_http_only = False
    try:
        charts_http_only = bool(ui.get("charts_http_only", False))
    except Exception:
        charts_http_only = False

    if isinstance(snap, dict) and snap:
        # Use snapshot directly as an "event-like" record; append_event() reads from the dict.
        new_events = [snap]
    elif not charts_http_only:
        # Fallback: tail events.jsonl and utd_events.jsonl incrementally (bounded by last offsets).
        try:
            epath = os.path.join(run_dir, "events.jsonl")
            if os.path.exists(epath):
                new_events, esize = tail_jsonl_bytes(epath, prev_es)
        except Exception:
            new_events, esize = [], prev_es
        try:
            upath = os.path.join(run_dir, "utd_events.jsonl")
            if os.path.exists(upath):
                new_utd, usize = tail_jsonl_bytes(upath, prev_us)
        except Exception:
            new_utd, usize = [], prev_us
    else:
        # Keep empty tails; rely on HTTP to populate when available.
        new_events, new_utd = [], []
        esize, usize = prev_es, prev_us

    # Reset conditions:
    truncated = (prev_es > 0 and esize < prev_es) or (prev_us > 0 and usize < prev_us)

    # 1) Explicit run restart marker from backend (logged at nexus start)
    restart_marker = False
    try:
        for rec in new_events:
            name = str(
                rec.get("event_type")
                or rec.get("event")
                or rec.get("message")
                or rec.get("msg")
                or rec.get("name")
                or ""
            ).lower()
            if name in ("nexus_started", "engram_loaded"):
                restart_marker = True
                break
    except Exception:
        pass

    # 2) Tick regression (incoming ticks lower than last known)
    tick_regression = False
    try:
        last_t = state.t[-1] if state.t else None
        if last_t is not None:
            min_new_t = None
            for rec in new_events:
                tv = extract_tick(rec)
                if tv is None:
                    continue
                tv = int(tv)
                if min_new_t is None or tv < min_new_t:
                    min_new_t = tv
            if min_new_t is not None and min_new_t < last_t:
                tick_regression = True
    except Exception:
        pass

    if truncated or restart_marker or tick_regression:
        # Clear buffers while keeping run_dir; prevents graph overlay on resume/restart.
        # Also advance offsets to current EOF so we don't re-ingest old tail data.
        try:
            state.__post_init__()  # re-init SeriesState buffers and counters
            state.events_size = esize
            state.utd_size = usize
            new_events = []
            new_utd = []
        except Exception:
            pass

    # Apply tails after optional reset
    for rec in new_events:
        append_event(state, rec)
    for rec in new_utd:
        append_say(state, rec)
    state.events_size = esize
    state.utd_size = usize

    # Bound buffers (UI-tunable; no env)
    try:
        MAXP = int(ui.get("maxp", 1200))
    except Exception:
        MAXP = 1200
    if len(state.t) > MAXP:
        state.t = state.t[-MAXP:]
        state.active = state.active[-MAXP:]
        state.avgw = state.avgw[-MAXP:]
        state.coh = state.coh[-MAXP:]
        state.comp = state.comp[-MAXP:]
        state.b1z = state.b1z[-MAXP:]
        state.val = state.val[-MAXP:]
        state.val2 = state.val2[-MAXP:]
        state.entro = state.entro[-MAXP:]
    # Speak tick overlay window (fixed UI-default)
    MAX_SAY = 800
    if len(state.speak_ticks) > MAX_SAY:
        state.speak_ticks = state.speak_ticks[-MAX_SAY:]

    # Forward-fill holes
    t = state.t
    active = ffill(state.active)
    avgw = ffill(state.avgw)
    coh = ffill(state.coh)
    comp = ffill(state.comp)
    b1z = ffill(state.b1z)
    val = ffill(state.val)
    val2 = ffill(state.val2)
    entro = ffill(state.entro)

    # Optional decimation to bound plotting work (UI-only). Applied after MAXP slicing.
    # Env:
    #   DASH_DECIMATE_TO = 0 (off) or N (target max plotted points per series)
    try:
        DEC_TO = int(ui.get("decimate", 600))
    except Exception:
        DEC_TO = 600
    if DEC_TO > 0 and len(t) > DEC_TO:
        stride = max(1, int(math.ceil(len(t) / float(DEC_TO))))
        def _dec(seq):
            return seq[::stride] if stride > 1 else seq
        t = t[::stride]
        active = _dec(active)
        avgw = _dec(avgw)
        coh = _dec(coh)
        comp = _dec(comp)
        b1z = _dec(b1z)
        val = _dec(val)
        val2 = _dec(val2)
        entro = _dec(entro)

    # Palette (env-overridable)
    def _env_color(k: str, default: str) -> str:
        try:
            v = os.getenv(f"DASH_COLOR_{k.upper()}", "").strip()
            return v if v else default
        except Exception:
            return default

    C = {
        "synapses": _env_color("synapses", "#7aa2c7"),
        "avgw": _env_color("avgw", "#9ab8d1"),
        "valence": _env_color("valence", "#c39b70"),
        "valence2": _env_color("valence2", "#8bb995"),
        "components": _env_color("components", "#b68484"),
        "cycles": _env_color("cycles", "#a08878"),
        "b1z": _env_color("b1z", "#76b0a7"),
        "entropy": _env_color("entropy", "#a495c7"),
        "speak_line": _env_color("speak_line", "rgba(120,180,120,0.45)"),
    }

    # fig1
    fig1 = go.Figure()
    # Enforce series_cap (UI control; default 6). Prioritize essential series first.
    try:
        SERIES_CAP = int(ui.get("series_cap", 6))
    except Exception:
        SERIES_CAP = 6
    SERIES_CAP = max(1, min(8, SERIES_CAP))

    add_count = 0
    def _add_if(cond: bool, fn) -> None:
        nonlocal add_count
        if add_count >= SERIES_CAP:
            return
        if cond:
            fn()
            add_count += 1

    # Priority order: Active, Cycles, AvgW, B1z, Components, Valence, Valence2, Entropy
    _add_if(True, lambda: fig1.add_trace(
        go.Scattergl(x=t, y=active, name="Active synapses", line=dict(width=1, color=C["synapses"]))
    ))
    _add_if(True, lambda: fig1.add_trace(
        go.Scattergl(x=t, y=comp, name="Cycles", yaxis="y4", line=dict(width=1, color=C["cycles"]))
    ))
    _add_if(True, lambda: fig1.add_trace(
        go.Scattergl(x=t, y=avgw, name="Avg W", yaxis="y2", line=dict(width=1, color=C["avgw"]))
    ))
    _add_if(True, lambda: fig1.add_trace(
        go.Scattergl(x=t, y=b1z, name="B1 z", yaxis="y5", line=dict(width=1, color=C["b1z"]))
    ))
    _add_if(True, lambda: fig1.add_trace(
        go.Scattergl(x=t, y=coh, name="Components", yaxis="y3", line=dict(width=1, color=C["components"]))
    ))
    _add_if(any(v is not None for v in val), lambda: fig1.add_trace(
        go.Scattergl(x=t, y=val, name="SIE valence", yaxis="y2", line=dict(width=1, dash="dot", color=C["valence"]))
    ))
    _add_if(any(v is not None for v in val2), lambda: fig1.add_trace(
        go.Scattergl(x=t, y=val2, name="SIE v2 valence", yaxis="y2", line=dict(width=1, dash="dash", color=C["valence2"]))
    ))
    _add_if(any(v is not None for v in entro), lambda: fig1.add_trace(
        go.Scattergl(x=t, y=entro, name="Connectome entropy", yaxis="y6", line=dict(width=1, color=C["entropy"]))
    ))
    fig1.update_layout(
        title=f"Dashboard — {os.path.basename(run_dir)}",
        paper_bgcolor="#10151c",
        plot_bgcolor="#0f141a",
        font=dict(color="#cfd7e3"),
        xaxis=dict(domain=[0.05, 0.95], title="Tick", gridcolor="#233140", zerolinecolor="#233140"),
        yaxis=dict(title="Active synapses", side="left", gridcolor="#233140", zerolinecolor="#233140"),
        yaxis2=dict(overlaying="y", side="right", title="Avg W / Valence", showgrid=False, zeroline=False),
        yaxis3=dict(overlaying="y", side="left", position=0.02, showticklabels=False, showgrid=False, zeroline=False),
        yaxis4=dict(overlaying="y", side="right", position=0.98, showticklabels=False, showgrid=False, zeroline=False),
        yaxis5=dict(overlaying="y", side="right", position=0.96, showticklabels=False, showgrid=False, zeroline=False),
        yaxis6=dict(overlaying="y", side="left", position=0.04, showticklabels=False, showgrid=False, zeroline=False),
        legend=dict(orientation="h", bgcolor="rgba(0,0,0,0)"),
        margin=dict(l=40, r=20, t=40, b=40),
    )

    # fig2
    fig2 = go.Figure()
    fig2.add_trace(go.Scattergl(x=t, y=comp, name="Cycle hits", line=dict(width=1, color=C["cycles"])))
    for tk in state.speak_ticks[-200:]:
        fig2.add_vline(x=tk, line_width=1, line_dash="dash", line_color=C["speak_line"])
    fig2.add_trace(go.Scattergl(x=t, y=b1z, name="B1 z", yaxis="y2", line=dict(width=1, color=C["b1z"])))
    fig2.update_layout(
        title="Cycle Hits & B1 z",
        paper_bgcolor="#10151c",
        plot_bgcolor="#0f141a",
        font=dict(color="#cfd7e3"),
        xaxis=dict(title="Tick", gridcolor="#233140", zerolinecolor="#233140"),
        yaxis=dict(title="Cycle hits", gridcolor="#233140", zerolinecolor="#233140"),
        yaxis2=dict(overlaying="y", side="right", title="B1 z", showgrid=False, zeroline=False),
        legend=dict(orientation="h", bgcolor="rgba(0,0,0,0)"),
        margin=dict(l=40, r=20, t=40, b=40),
    )

    return fig1, fig2, state]]></content>
    </file>
    <file>
      <path>controllers/chat_controller.py</path>
      <content><![CDATA[from __future__ import annotations

from typing import Any, Dict, Iterable, List, Optional


def parse_utd_macro_record(rec: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """
    Convert a single UTD macro record into a standardized chat item dict.
    Expected rec schema (best-effort):
      { "type": "macro", "macro": "...", "args": {...}, "why": {...} }
    """
    if not isinstance(rec, dict):
        return None
    if rec.get("type") != "macro":
        return None

    macro_name = rec.get("macro", "unknown")
    args = rec.get("args", {}) or {}
    if macro_name == "say":
        text = args.get("text", "")
    else:
        text = f"macro: {macro_name}"
        if args:
            try:
                arg_str = ", ".join(f"{k}={v}" for k, v in args.items())
                text += f" ({arg_str})"
            except Exception:
                text += f" (args: {args})"

    # Extract why.t and spike-like markers if present
    why = rec.get("why") or {}
    t = None
    try:
        t = int((why or {}).get("t"))
    except Exception:
        t = None

    spike = False
    if isinstance(why, dict):
        try:
            speak_ok = why.get("speak_ok")
            spike = bool(speak_ok) or bool((why or {}).get("spike"))
        except Exception:
            spike = False

    return {"kind": "model", "text": str(text), "t": t, "spike": bool(spike), "macro": macro_name}


def items_from_utd_records(records: Iterable[Dict[str, Any]]) -> List[Dict[str, Any]]:
    out: List[Dict[str, Any]] = []
    for rec in (records or []):
        try:
            item = parse_utd_macro_record(rec)
            if item:
                out.append(item)
        except Exception:
            # ignore malformed lines
            pass
    return out


def items_from_inbox_records(records: Iterable[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Convert chat_inbox.jsonl records into standardized chat items.
    Supported entries (best-effort):
      - {"type": "text", "msg": "..."}  or {"type": "text", "text": "..."}
    """
    out: List[Dict[str, Any]] = []
    for rec in (records or []):
        try:
            if not isinstance(rec, dict):
                continue
            mtype = (rec.get("type") or "").lower()
            if mtype == "text":
                msg = rec.get("msg") or rec.get("text") or ""
                if msg:
                    out.append({"kind": "user", "text": str(msg), "t": None, "spike": False})
        except Exception:
            pass
    return out


def trim_items(items: List[Dict[str, Any]], limit: int = 200) -> List[Dict[str, Any]]:
    if not items:
        return []
    if len(items) <= limit:
        return items
    return items[-limit:]


def render_chat_view(items: List[Dict[str, Any]], filt: str = "all") -> str:
    """
    Render a plain-text view of chat items based on filter:
      - "all": show all
      - "say": only model items with macro == "say"
      - "spike": only model items with spike==True and macro == "say"
    """
    f = (filt or "all").lower()
    lines: List[str] = []

    for it in (items or []):
        if f == "say":
            if it.get("kind") != "model" or it.get("macro") != "say":
                continue
        elif f == "spike":
            if it.get("kind") != "model" or not it.get("spike", False) or it.get("macro") != "say":
                continue

        text = it.get("text") or ""
        if it.get("kind") == "user":
            lines.append(f"You: {text}")
        else:
            t = it.get("t")
            if t is not None:
                lines.append(f"[t={t}] {text}")
            else:
                lines.append(f"{text}")

    return "\n".join(lines)]]></content>
    </file>
    <file>
      <path>controllers/file_picker_controller.py</path>
      <content><![CDATA[from __future__ import annotations

"""
File Picker Controller Utilities

Purpose:
- Provide bounded, reusable filesystem helpers for the Dash file-picker
- Centralize path clamping, directory listing, and initial tree construction
- Ensure safety (no traversal beyond root), performance (scandir), and filtering (exts, dotfiles)

Design constraints:
- Sparse-first: single-directory listings only (no recursion)
- No schedulers
- No scans in core/ or maps/ (caller controls roots; we only walk the provided path)
- Contracts: Pure functions with deterministic outputs for given inputs
"""

import os
from typing import List, Tuple, Dict, Any


def clamp_to_root(path: str, root: str) -> str:
    """
    Clamp an arbitrary path to the provided root. If 'path' escapes 'root', return the root.

    Args:
        path: Any filesystem path (relative or absolute)
        root: Root boundary (absolute or relative, coerced to absolute internally)

    Returns:
        Absolute path inside 'root' (or the root itself when 'path' escapes)
    """
    try:
        root_abs = os.path.abspath(root)
        path_abs = os.path.abspath(path)
        common = os.path.commonpath([root_abs, path_abs])
        return path_abs if common == root_abs else root_abs
    except Exception:
        return os.path.abspath(root)


def is_within_root(path: str, root: str) -> bool:
    """
    Check if 'path' is within 'root' boundary.

    Returns:
        True if path is inside root, False otherwise (including exceptions).
    """
    try:
        root_abs = os.path.abspath(root)
        path_abs = os.path.abspath(path)
        return os.path.commonpath([root_abs, path_abs]) == root_abs
    except Exception:
        return False


def list_dir(path: str, exts: List[str] | None = None, hide_dotfiles: bool = True) -> Tuple[List[str], List[str]]:
    """
    List a single directory (bounded IO).

    Args:
        path: Directory to list (absolute or relative)
        exts: Optional list of allowed file extensions (e.g., [".json", ".csv"]); when None or empty, allow all
        hide_dotfiles: When True, hide entries whose name starts with '.'

    Returns:
        (subdirs, files) — both sorted, names only (no absolute paths)

    Policy:
        - No scans in 'core/' or 'maps/' at any depth. If the resolved path contains either
          restricted segment, short-circuit and return empty results. This enforces the global
          guard while keeping IO strictly bounded.
    """
    subdirs: List[str] = []
    files: List[str] = []
    try:
        pabs = os.path.abspath(path)
        # Enforce "no scans in core/ or maps/" at any depth
        parts = os.path.normpath(pabs).split(os.sep)
        if "core" in parts or "maps" in parts:
            return [], []

        lower_exts = [e.lower() for e in (exts or [])]
        allow_all = not lower_exts
        with os.scandir(pabs) as it:
            for entry in it:
                name = entry.name
                if hide_dotfiles and name.startswith("."):
                    continue
                try:
                    if entry.is_dir(follow_symlinks=False):
                        # Don't even offer restricted dirs for expansion
                        if name not in ("core", "maps"):
                            subdirs.append(name)
                    else:
                        if allow_all or any(name.lower().endswith(e) for e in lower_exts):
                            files.append(name)
                except Exception:
                    # Skip entries that cause IO/stat errors
                    continue
    except Exception:
        return [], []
    subdirs.sort()
    files.sort()
    return subdirs, files


def init_tree(root: str, exts: List[str] | None = None, hide_dotfiles: bool = True) -> Dict[str, Any]:
    """
    Construct the initial tree structure for a file-picker rooted at 'root'.

    Structure:
        {
          "root": <abs_root>,
          "nodes": {
             <abs_root>: {
                "expanded": True,
                "subdirs": [<names>],
                "files": [<names>]
             }
          }
        }

    Notes:
      - Bounded IO: lists only the root directory once for initialization
      - No recursion; deeper nodes are discovered on user toggle via list_dir()
    """
    rabs = os.path.abspath(root)
    subdirs, files = list_dir(rabs, exts=exts, hide_dotfiles=hide_dotfiles)
    return {
        "root": rabs,
        "nodes": {
            rabs: {
                "expanded": True,
                "subdirs": subdirs or [],
                "files": files or [],
            }
        },
    }


def next_children(path: str, exts: List[str] | None = None, hide_dotfiles: bool = True) -> Tuple[List[str], List[str]]:
    """
    One-step discovery for a directory node. Intended for use when the user expands a folder.
    """
    pabs = os.path.abspath(path)
    return list_dir(pabs, exts=exts, hide_dotfiles=hide_dotfiles)]]></content>
    </file>
    <file>
      <path>controllers/file_picker_ctx.py</path>
      <content><![CDATA[from __future__ import annotations

"""
File Picker Dash Context Helpers

Atomic helper(s) to robustly parse Dash callback_context for pattern-matched components.
"""

from typing import Optional, Dict, Any


def get_trigger_id_obj(ctx) -> Optional[Dict[str, Any]]:
    """
    Return the pattern-matched dict id for the triggering component if available.
    Works on newer Dash (ctx.triggered_id) and older (JSON prop_id).
    """
    try:
        tid = getattr(ctx, "triggered_id", None)
        if isinstance(tid, dict):
            return tid
    except Exception:
        pass
    try:
        import json  # local import to keep dependency surface minimal
        if getattr(ctx, "triggered", None):
            tid_s = ctx.triggered[0]["prop_id"].rsplit(".", 1)[0]
            return json.loads(tid_s)
    except Exception:
        return None
    return None]]></content>
    </file>
    <file>
      <path>controllers/file_picker_status.py</path>
      <content><![CDATA[from __future__ import annotations

"""
File Picker Status/Formatting Controller (atomic helpers)

Purpose:
- Pure helpers used by Dash callbacks and widgets to compute status strings and sizes
- Keep IO bounded and consistent with global guards via controller.list_dir()

Contracts:
- No recursion. Single-directory listings only.
- No scans in core/ or maps/ are enforced by file_picker_controller.list_dir
- Deterministic outputs; exceptions are contained and produce safe fallbacks.
"""

import os
from typing import List

from fum_rt.frontend.controllers.file_picker_controller import (
    list_dir as _ctl_list_dir,
)


def human_size(n: int | float) -> str:
    """
    Convert a byte count to a human-readable string.
    """
    try:
        n = int(n)
    except Exception:
        return "0 B"
    units = [("TB", 1024**4), ("GB", 1024**3), ("MB", 1024**2), ("KB", 1024), ("B", 1)]
    for label, factor in units:
        if n >= factor:
            if factor == 1:
                return f"{n} B"
            return f"{n / factor:.2f} {label}"
    return "0 B"


def sum_filesizes(dir_path: str, filenames: List[str] | None) -> int:
    """
    Sum sizes of the given filenames inside dir_path (non-recursive).
    """
    total = 0
    for name in (filenames or []):
        try:
            fp = os.path.join(dir_path, name)
            if os.path.isfile(fp):
                total += os.path.getsize(fp)
        except Exception:
            continue
    return total


def file_status_text(file_path: str) -> str:
    """
    Build status text for a single file path.
    """
    base = os.path.basename(file_path or "")
    try:
        size_b = os.path.getsize(file_path) if os.path.isfile(file_path) else 0
        return f"File: {base} — Size: {human_size(size_b)}"
    except Exception:
        return f"File: {base} — Size: unknown"


def directory_status_text(dir_path: str, exts: List[str] | None = None, hide_dotfiles: bool = True) -> str:
    """
    Build status text for a directory: counts and aggregate size of visible files.

    IO is strictly bounded to a single directory via controller.list_dir.
    """
    try:
        if not (dir_path and os.path.isdir(dir_path)):
            return "Contains: 0 folders; 0 files; Total Size: 0 B"
        subdirs, files = _ctl_list_dir(dir_path, exts=exts or [], hide_dotfiles=hide_dotfiles)
        folders_n = len(subdirs or [])
        files_n = len(files or [])
        total_b = sum_filesizes(dir_path, files or [])
        return f"Contains: {folders_n} folders; {files_n} files; Total Size: {human_size(total_b)}"
    except Exception:
        return "Contains: 0 folders; 0 files; Total Size: 0 B"]]></content>
    </file>
    <file>
      <path>controllers/runtime_controller.py</path>
      <content><![CDATA[from __future__ import annotations

import os
from typing import Any, Dict, Iterable, Optional

from fum_rt.frontend.utilities.profiles import safe_int as _safe_int, safe_float as _safe_float
from fum_rt.frontend.utilities.fs_utils import read_json_file, write_json_file, latest_checkpoint


def build_phase_update(
    default_profile: Dict[str, Any],
    phase,
    s_z,
    s_h,
    s_cd,
    s_vt,
    c_w,
    c_h,
    c_b,
    c_pf,
    c_thr,
    c_lw,
    c_cand,
    s_idf,
) -> Dict[str, Any]:
    """
    Build a dict of runtime/phase settings, coercing types with defaults.
    This normalizes UI inputs into a consistent structure.
    """
    return {
        "phase": int(_safe_int(phase, 0)),
        "speak": {
            "speak_z": float(_safe_float(s_z, default_profile["speak_z"])),
            "speak_hysteresis": float(_safe_float(s_h, default_profile["speak_hysteresis"])),
            "speak_cooldown_ticks": int(_safe_int(s_cd, default_profile["speak_cooldown_ticks"])),
            "speak_valence_thresh": float(_safe_float(s_vt, default_profile["speak_valence_thresh"])),
        },
        "connectome": {
            "walkers": int(_safe_int(c_w, default_profile["walkers"])),
            "hops": int(_safe_int(c_h, default_profile["hops"])),
            "bundle_size": int(_safe_int(c_b, default_profile["bundle_size"])),
            "prune_factor": float(_safe_float(c_pf, default_profile["prune_factor"])),
            "threshold": float(_safe_float(c_thr, default_profile.get("threshold", 0.15))),
            "lambda_omega": float(_safe_float(c_lw, default_profile.get("lambda_omega", 0.10))),
            "candidates": int(_safe_int(c_cand, default_profile.get("candidates", 64))),
        },
        "sie": {"novelty_idf_gain": float(_safe_float(s_idf, 1.0))},
    }


def _merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    """
    Shallow-merge with one level of deep-merge for nested dicts 'speak' and 'connectome'.
    Preserves keys like 'load_engram' in existing phase.json while applying updates.
    """
    out = dict(a or {})
    for k, v in (b or {}).items():
        if isinstance(v, dict) and isinstance(out.get(k), dict):
            nv = dict(out[k])
            nv.update(v)
            out[k] = nv
        else:
            out[k] = v
    return out


def update_phase_json(run_dir: str, update: Dict[str, Any]) -> bool:
    """
    Merge-update run_dir/phase.json with the provided update dict.
    Ensures directory exists; returns True on successful write.
    """
    try:
        os.makedirs(run_dir, exist_ok=True)
        p = os.path.join(run_dir, "phase.json")
        current = read_json_file(p) or {}
        if not isinstance(current, dict):
            current = {}
        merged = _merge(current, update)
        return write_json_file(p, merged)
    except Exception:
        return False


def queue_load_engram(run_dir: str, path: str) -> tuple[bool, str]:
    """
    Add/overwrite 'load_engram' in phase.json, preserving other keys.
    Normalizes directories to the latest checkpoint file to prevent loader errors.
    Returns (ok, normalized_path) so the UI can echo the actual target.
    """
    try:
        os.makedirs(run_dir, exist_ok=True)
        p = os.path.join(run_dir, "phase.json")
        obj = read_json_file(p) or {}
        if not isinstance(obj, dict):
            obj = {}
        # Normalize provided path:
        target = (path or "").strip()
        if not target:
            return False, ""
        # If a directory was provided, resolve to latest checkpoint inside it
        if os.path.isdir(target):
            lp = latest_checkpoint(target)
            if not lp:
                return False, ""
            target = lp
        else:
            # If file doesn't exist, try resolving relative to run_dir
            if not os.path.exists(target):
                cand = os.path.join(run_dir, target)
                if os.path.isdir(cand):
                    lp = latest_checkpoint(cand)
                    if not lp:
                        return False, ""
                    target = lp
                elif os.path.exists(cand):
                    target = cand
                else:
                    return False, ""
        obj["load_engram"] = target
        ok = write_json_file(p, obj)
        return (True, target) if ok else (False, "")
    except Exception:
        return False, ""


def parse_engram_events_for_message(records: Iterable[Dict[str, Any]]) -> Optional[str]:
    """
    Scan a set of event dicts and derive a user-facing message summarizing an engram load result.
    Returns the last relevant message if multiple are present.
    """
    msg: Optional[str] = None
    for rec in (records or []):
        if not isinstance(rec, dict):
            continue
        name = str(
            rec.get("event_type")
            or rec.get("event")
            or rec.get("message")
            or rec.get("msg")
            or rec.get("name")
            or ""
        ).lower()
        extra = rec.get("extra") or rec.get("meta") or {}
        if name == "engram_loaded":
            engram_path = extra.get("path") or extra.get("engram") or rec.get("path")
            msg = f"Engram loaded: {engram_path}" if engram_path else "Engram loaded."
        elif name == "engram_load_error":
            err = extra.get("err") or extra.get("error") or rec.get("error")
            engram_path = extra.get("path") or extra.get("engram") or rec.get("path")
            if err and engram_path:
                msg = f"Engram load error: {err} ({engram_path})"
            elif err:
                msg = f"Engram load error: {err}"
            else:
                msg = "Engram load error."
    return msg]]></content>
    </file>
    <file>
      <path>debug_ui.py</path>
      <content><![CDATA[from __future__ import annotations

import os
import time
from typing import List, Dict, Any

from dash import Dash, html, dcc
from dash.dependencies import Input, Output, State  # type: ignore
import plotly.graph_objects as go

# Reuse existing lightweight filesystem utilities (no heavy scans)
from fum_rt.frontend.utilities.fs_utils import list_runs
from fum_rt.frontend.controllers.charts_controller import compute_dashboard_figures as _compute_dashboard_figures
from fum_rt.frontend.models.series import SeriesState as _SeriesState
# Optional: reuse controller to hook components incrementally
from fum_rt.frontend.controllers.charts_controller import compute_dashboard_figures as _compute_dashboard_figures
from fum_rt.frontend.models.series import SeriesState as _SeriesState


def _abs(path: str) -> str:
    try:
        return path if os.path.isabs(path) else os.path.abspath(path)
    except Exception:
        return path


def _file_stat(path: str) -> Dict[str, Any]:
    """
    Cheap file stat: no full read, only exists/size/mtime.
    """
    try:
        if not os.path.exists(path):
            return {"exists": False, "size": 0, "mtime": 0.0}
        return {
            "exists": True,
            "size": os.path.getsize(path) if os.path.isfile(path) else 0,
            "mtime": os.path.getmtime(path),
        }
    except Exception:
        return {"exists": False, "size": 0, "mtime": 0.0}


def _dir_stat(path: str) -> Dict[str, Any]:
    """
    Cheap dir stat: exists, dir mtime, count of subdirs (first-level).
    Avoids walking recursively; bounded and cheap.
    """
    try:
        if not os.path.isdir(path):
            return {"exists": False, "mtime": 0.0, "dirs": 0}
        try:
            mt = os.path.getmtime(path)
        except Exception:
            mt = 0.0
        try:
            cnt = sum(1 for n in os.listdir(path) if os.path.isdir(os.path.join(path, n)))
        except Exception:
            cnt = 0
        return {"exists": True, "mtime": mt, "dirs": cnt}
    except Exception:
        return {"exists": False, "mtime": 0.0, "dirs": 0}


def _runs_options(root: str) -> List[Dict[str, str]]:
    """
    Options for run-dir dropdown. Uses list_runs(root) which returns absolute paths,
    sorted by mtime desc (cheap).
    """
    try:
        runs = list_runs(root)
    except Exception:
        runs = []
    return [{"label": os.path.basename(p.rstrip(os.path.sep)) or p, "value": p} for p in runs]


def build_debug_app(runs_root: str) -> Dash:
    """
    Minimal, surgical debug UI:
    - No charts, no complex callbacks
    - Only polls a selected run_dir and reports file sizes/mtimes
    - Designed to isolate UI overhead vs backend/logging issues
    """
    app = Dash(
        __name__,
        prevent_initial_callbacks=True,
        suppress_callback_exceptions=True,
    )
    app.title = "FUM Debug UI"

    rr_abs = _abs(runs_root) or _abs("runs")
    runs_opts = _runs_options(rr_abs)
    default_run = runs_opts[0]["value"] if runs_opts else ""

    # Layout: runs root input + refresh button, run-dir dropdown, poll interval, component toggles, stats and graphs
    app.layout = html.Div(
        [
            html.H3("FUM Debug UI — Minimal"),
            html.Div(
                [
                    html.Label("Runs root"),
                    dcc.Input(id="dbg-runs-root", type="text", value=rr_abs, style={"width": "100%"}),
                    html.Button("Refresh", id="dbg-refresh", n_clicks=0),
                ],
                style={"display": "grid", "gap": "8px", "maxWidth": "640px"},
            ),
            html.Div(
                [
                    html.Label("Run directory"),
                    dcc.Dropdown(
                        id="dbg-run-dir",
                        options=runs_opts,
                        value=default_run,
                        style={"minWidth": "360px"},
                    ),
                ],
                style={"display": "grid", "gap": "8px", "maxWidth": "640px", "marginTop": "8px"},
            ),
            html.Div(
                [
                    html.Label("Polling"),
                    dcc.Checklist(
                        id="dbg-poll-enabled",
                        options=[{"label": "Enable polling", "value": "on"}],
                        value=["on"],
                        inline=True,
                    ),
                    dcc.Slider(
                        id="dbg-poll-ms",
                        min=250,
                        max=5000,
                        step=250,
                        value=1000,
                        tooltip={"always_visible": False},
                    ),
                ],
                style={"display": "grid", "gap": "8px", "maxWidth": "640px", "marginTop": "8px"},
            ),
            html.Div(
                [
                    html.Label("Components"),
                    dcc.Checklist(
                        id="dbg-components",
                        options=[
                            {"label": "Tiny chart: file sizes", "value": "file_sizes"},
                            {"label": "Controller charts (dashboard + discovery)", "value": "controller_charts"},
                        ],
                        value=["file_sizes"],
                        inline=False,
                    ),
                ],
                style={"display": "grid", "gap": "8px", "maxWidth": "960px", "marginTop": "8px"},
            ),
            html.Div(
                [
                    html.Label("Controller settings"),
                    html.Div(
                        [
                            html.Div(
                                [
                                    html.Label("Status URL"),
                                    dcc.Input(id="dbg-ctrl-status-url", type="text", value="http://127.0.0.1:8787/status/snapshot", style={"width": "100%"}),
                                ],
                                style={"minWidth": "280px"},
                            ),
                            html.Div(
                                [
                                    html.Label("Status timeout (s)"),
                                    dcc.Input(id="dbg-ctrl-status-timeout", type="number", value=0.2, min=0.05, step=0.05),
                                ]
                            ),
                            html.Div(
                                [
                                    html.Label("Points cap (maxp)"),
                                    dcc.Input(id="dbg-ctrl-points-cap", type="number", value=800, min=50, step=50),
                                ]
                            ),
                            html.Div(
                                [
                                    html.Label("Series cap"),
                                    dcc.Input(id="dbg-ctrl-series-cap", type="number", value=4, min=1, step=1),
                                ]
                            ),
                            html.Div(
                                [
                                    html.Label("Decimate to N points (0=off)"),
                                    dcc.Input(id="dbg-ctrl-decimate", type="number", value=400, min=0, step=50),
                                ]
                            ),
                        ],
                        className="row",
                    ),
                ],
                style={"display": "grid", "gap": "8px", "maxWidth": "960px", "marginTop": "8px"},
            ),
            # Graphs (rendered empty unless enabled via dbg-components)
            html.Div(
                [
                    dcc.Graph(id="dbg-fig", figure=go.Figure(), style={"minHeight": "220px"}),
                    dcc.Graph(id="dbg-fig-dashboard", figure=go.Figure(), style={"minHeight": "360px"}),
                    dcc.Graph(id="dbg-fig-discovery", figure=go.Figure(), style={"minHeight": "300px"}),
                ],
                style={"display": "grid", "gap": "16px", "maxWidth": "1200px"},
            ),
            dcc.Interval(id="dbg-interval", interval=1000, n_intervals=0, disabled=False),
            html.Hr(),
            html.Pre(id="dbg-stats", children="Waiting for data..."),
            dcc.Store(id="dbg-state"),
        ],
        style={"padding": "10px", "fontFamily": "sans-serif"},
    )

    # Callbacks
    @app.callback(
        Output("dbg-run-dir", "options", allow_duplicate=True),
        Output("dbg-run-dir", "value", allow_duplicate=True),
        Input("dbg-refresh", "n_clicks"),
        State("dbg-runs-root", "value"),
        prevent_initial_call=True,
    )
    def on_refresh_runs(_n, root):
        r = (_abs(root or "")).strip()
        if not r:
            raise Exception("Runs root is empty")
        opts = _runs_options(r)
        val = opts[0]["value"] if opts else ""
        return opts, val

    @app.callback(
        Output("dbg-interval", "interval", allow_duplicate=True),
        Output("dbg-interval", "disabled", allow_duplicate=True),
        Input("dbg-poll-ms", "value"),
        Input("dbg-poll-enabled", "value"),
        prevent_initial_call=True,
    )
    def on_poll_config(ms, enabled_vals):
        try:
            interval = int(ms) if ms else 1000
        except Exception:
            interval = 1000
        disabled = ("on" not in (enabled_vals or []))
        return max(250, interval), disabled

    @app.callback(
        Output("dbg-stats", "children", allow_duplicate=True),
        Input("dbg-interval", "n_intervals"),
        State("dbg-run-dir", "value"),
        State("dbg-runs-root", "value"),
        prevent_initial_call=False,
    )
    def on_tick(_n, rd, rr):
        t0 = time.perf_counter()

        rr_abs_local = _abs((rr or "").strip())
        rd_local = (rd or "").strip()
        if rd_local and not os.path.isabs(rd_local):
            # Normalize run_dir against runs_root (defensive)
            rd_abs = _abs(os.path.join(rr_abs_local, rd_local))
        else:
            rd_abs = rd_local

        # Resolve key file stats in the selected run
        events_path = os.path.join(rd_abs, "events.jsonl") if rd_abs else ""
        utd_path = os.path.join(rd_abs, "utd_events.jsonl") if rd_abs else ""
        phase_path = os.path.join(rd_abs, "phase.json") if rd_abs else ""

        rr_stat = _dir_stat(rr_abs_local) if rr_abs_local else {"exists": False, "mtime": 0.0, "dirs": 0}
        rd_exists = os.path.isdir(rd_abs) if rd_abs else False
        events_stat = _file_stat(events_path) if rd_abs else {"exists": False, "size": 0, "mtime": 0.0}
        utd_stat = _file_stat(utd_path) if rd_abs else {"exists": False, "size": 0, "mtime": 0.0}
        phase_stat = _file_stat(phase_path) if rd_abs else {"exists": False, "size": 0, "mtime": 0.0}

        # Also surface a cheap "top N" run dirs snapshot for verification (labels only)
        try:
            runs_list = list_runs(rr_abs_local)[:6]
        except Exception:
            runs_list = []

        dt_ms = int((time.perf_counter() - t0) * 1000.0)
        now_s = time.strftime("%Y-%m-%d %H:%M:%S")

        # Produce a compact, human-readable diagnostics block (no heavy formatting)
        lines = []
        lines.append(f"[{now_s}] server_callback_ms={dt_ms}")
        lines.append(f"runs_root_abs={rr_abs_local}")
        lines.append(f"runs_root_exists={rr_stat.get('exists')} subdirs={rr_stat.get('dirs')} mtime={rr_stat.get('mtime'):.3f}")
        lines.append(f"run_dir={rd_abs}")
        lines.append(f"run_dir_exists={rd_exists}")
        lines.append(f"events.jsonl exists={events_stat['exists']} size={events_stat['size']} mtime={events_stat['mtime']:.3f}")
        lines.append(f"utd_events.jsonl exists={utd_stat['exists']} size={utd_stat['size']} mtime={utd_stat['mtime']:.3f}")
        lines.append(f"phase.json exists={phase_stat['exists']} size={phase_stat['size']} mtime={phase_stat['mtime']:.3f}")
        lines.append("runs_head:")
        for p in runs_list:
            lines.append(f"  - {p}")
        try:
            _c_ms = int(getattr(on_controller_figs, "_last_ms", -1))
        except Exception:
            _c_ms = -1
        lines.append(f"controller_dt_ms={_c_ms}")
        return "\n".join(lines)

    # Minimal figure: file size over time (isolates Plotly/dash overhead)
    @app.callback(
        Output("dbg-fig", "figure", allow_duplicate=True),
        Input("dbg-interval", "n_intervals"),
        State("dbg-components", "value"),
        State("dbg-run-dir", "value"),
        State("dbg-runs-root", "value"),
        prevent_initial_call=False,
    )
    def on_fig(_n, comps, rd, rr):
        comps = comps or []
        if "file_sizes" not in comps:
            return go.Figure()

        # Resolve absolute run_dir
        rr_abs_local = _abs((rr or "").strip())
        rd_local = (rd or "").strip()
        if rd_local and not os.path.isabs(rd_local):
            rd_abs = _abs(os.path.join(rr_abs_local, rd_local))
        else:
            rd_abs = rd_local

        events_path = os.path.join(rd_abs, "events.jsonl") if rd_abs else ""
        utd_path = os.path.join(rd_abs, "utd_events.jsonl") if rd_abs else ""

        e_stat = _file_stat(events_path) if rd_abs else {"exists": False, "size": 0}
        u_stat = _file_stat(utd_path) if rd_abs else {"exists": False, "size": 0}

        series = getattr(on_fig, "_series", {"t": [], "events": [], "utd": []})
        t = series["t"]; ev = series["events"]; ut = series["utd"]
        t.append(len(t) + 1)
        ev.append(int(e_stat.get("size", 0)))
        ut.append(int(u_stat.get("size", 0)))

        # Keep small ring buffer to bound memory/CPU
        if len(t) > 256:
            t[:] = t[-256:]; ev[:] = ev[-256:]; ut[:] = ut[-256:]
        setattr(on_fig, "_series", series)

        fig = go.Figure()
        if ev:
            fig.add_trace(go.Scatter(x=t, y=[x / 1e6 for x in ev], name="events.jsonl MB", mode="lines"))
        if ut:
            fig.add_trace(go.Scatter(x=t, y=[x / 1e6 for x in ut], name="utd_events.jsonl MB", mode="lines"))

        fig.update_layout(
            template="plotly_dark",
            margin=dict(l=30, r=10, t=30, b=30),
            xaxis_title="Tick",
            yaxis_title="Size (MB)",
            legend=dict(orientation="h"),
        )
        return fig

    # Controller charts (reuse production controller with small, bounded UI knobs)
    @app.callback(
        Output("dbg-fig-dashboard", "figure", allow_duplicate=True),
        Output("dbg-fig-discovery", "figure", allow_duplicate=True),
        Input("dbg-interval", "n_intervals"),
        State("dbg-components", "value"),
        State("dbg-run-dir", "value"),
        State("dbg-runs-root", "value"),
        State("dbg-ctrl-status-url", "value"),
        State("dbg-ctrl-status-timeout", "value"),
        State("dbg-ctrl-points-cap", "value"),
        State("dbg-ctrl-series-cap", "value"),
        State("dbg-ctrl-decimate", "value"),
        prevent_initial_call=False,
    )
    def on_controller_figs(_n, comps, rd, rr, status_url, status_timeout, points_cap, series_cap, decimate_to):
        comps = comps or []
        if "controller_charts" not in comps:
            return go.Figure(), go.Figure()

        # Resolve absolute run_dir
        rr_abs_local = _abs((rr or "").strip())
        rd_local = (rd or "").strip()
        if rd_local and not os.path.isabs(rd_local):
            rd_abs = _abs(os.path.join(rr_abs_local, rd_local))
        else:
            rd_abs = rd_local

        # Build UI dict for controller
        try:
            ui = {
                "status_url": str(status_url or "http://127.0.0.1:8787/status/snapshot"),
                "status_timeout": float(status_timeout if status_timeout is not None else 0.2),
                "maxp": int(points_cap if points_cap is not None else 800),
                "series_cap": int(series_cap if series_cap is not None else 4),
                "decimate": int(decimate_to if decimate_to is not None else 400),
            }
        except Exception:
            ui = {
                "status_url": "http://127.0.0.1:8787/status/snapshot",
                "status_timeout": 0.2,
                "maxp": 800,
                "series_cap": 4,
                "decimate": 400,
            }

        # Persist SeriesState between ticks (per-run)
        state = getattr(on_controller_figs, "_state", None)
        if not isinstance(state, _SeriesState) or getattr(state, "run_dir", None) != rd_abs:
            state = _SeriesState(rd_abs or "")
        t0 = time.perf_counter()
        fig1, fig2, new_state = _compute_dashboard_figures(rd_abs or "", state, ui)
        try:
            setattr(on_controller_figs, "_last_ms", int((time.perf_counter() - t0) * 1000.0))
        except Exception:
            pass
        setattr(on_controller_figs, "_state", new_state)
        return fig1, fig2

    return app


if __name__ == "__main__":
    # Environment-driven defaults for manual testing:
    # RUNS_ROOT: override runs root; default to ./runs
    # DASH_HOST / DASH_PORT: debug server bind (default 127.0.0.1:8060)
    rr = os.getenv("RUNS_ROOT", "").strip() or _abs("runs")
    app = build_debug_app(rr)
    host = os.getenv("DASH_HOST", "127.0.0.1")
    try:
        port = int(os.getenv("DASH_PORT", "8060"))
    except Exception:
        port = 8060
    # No debug reloader to avoid duplicate callbacks; UI is already minimal
    app.run(host=host, port=port, debug=False)]]></content>
    </file>
    <file>
      <path>models/series.py</path>
      <content><![CDATA[from __future__ import annotations

import os
import math
from typing import Any, Dict, List
from dataclasses import dataclass


class StreamingZEMA:
    """
    Streaming z-score of deltas (ZEMA) with exponential moving averages.
    Matches legacy dashboard behavior exactly.
    """
    def __init__(self, half_life_ticks: int = 120):
        self.alpha = 1.0 - math.exp(math.log(0.5) / float(max(1, int(half_life_ticks))))
        self.mu = 0.0
        self.var = 1e-6
        self.prev = None

    def update(self, v: float) -> float:
        v = float(v)
        if self.prev is None:
            self.prev = v
            return 0.0
        d = v - self.prev
        self.prev = v
        a = self.alpha
        self.mu = (1.0 - a) * self.mu + a * d
        diff = d - self.mu
        self.var = (1.0 - a) * self.var + a * (diff * diff)
        sigma = (self.var if self.var > 1e-24 else 1e-24) ** 0.5
        return float(diff / sigma)


@dataclass
class SeriesState:
    """
    Rolling buffers for timeseries in the dashboard (unchanged semantics).
    """
    run_dir: str

    def __post_init__(self):
        self.events_path = os.path.join(self.run_dir, "events.jsonl")
        self.utd_path = os.path.join(self.run_dir, "utd_events.jsonl")
        self.events_size = 0
        self.utd_size = 0
        self.b1_ema = StreamingZEMA(half_life_ticks=120)
        self.t: List[int] = []
        self.active: List[float | None] = []
        self.avgw: List[float | None] = []
        self.coh: List[float | None] = []
        self.comp: List[float | None] = []
        self.b1z: List[float | None] = []
        self.val: List[float | None] = []
        self.val2: List[float | None] = []
        self.entro: List[float | None] = []
        self.speak_ticks: List[int] = []


def extract_tick(rec: Dict[str, Any]) -> int | None:
    for k in ("t", "tick"):
        if k in rec:
            try:
                return int(rec[k])
            except Exception:
                pass
    ex = rec.get("extra", {})
    for k in ("t", "tick"):
        if k in ex:
            try:
                return int(ex[k])
            except Exception:
                pass
    return None


def append_event(ss: SeriesState, rec: Dict[str, Any]):
    t = extract_tick(rec)
    if t is None:
        return
    ex = rec.get("extra", rec)
    ss.t.append(int(t))
    ss.active.append(ex.get("active_synapses"))
    ss.avgw.append(ex.get("avg_weight"))
    ss.coh.append(ex.get("cohesion_components"))
    cc = ex.get("complexity_cycles")
    ss.comp.append(cc)
    bz = ex.get("b1_z")
    if bz is None:
        v = 0.0 if cc is None else float(cc)
        bz = ss.b1_ema.update(v)
    ss.b1z.append(float(bz))
    # Robust SIE valence extraction with fallbacks (handles various field names and ranges)
    val = ex.get("sie_valence_01")
    if val is None:
        for k in ("sie_valence", "valence"):
            v = ex.get(k)
            if v is not None:
                try:
                    fv = float(v)
                    # Normalize [-1,1] -> [0,1] if appropriate
                    val = (fv + 1.0) / 2.0 if -1.001 <= fv <= 1.001 else fv
                except Exception:
                    val = v
                break
        if val is None:
            sie = ex.get("sie") or {}
            if isinstance(sie, dict):
                if "valence_01" in sie:
                    val = sie.get("valence_01")
                elif "valence" in sie:
                    try:
                        fv = float(sie.get("valence"))
                        val = (fv + 1.0) / 2.0 if -1.001 <= fv <= 1.001 else fv
                    except Exception:
                        val = sie.get("valence")
    ss.val.append(val)
    val2 = ex.get("sie_v2_valence_01")
    if val2 is None:
        for k in ("sie_v2_valence", "sie_v2"):
            v = ex.get(k)
            if v is not None:
                try:
                    fv = float(v)
                    val2 = (fv + 1.0) / 2.0 if -1.001 <= fv <= 1.001 else fv
                except Exception:
                    val2 = v
                break
        if val2 is None:
            sie2 = ex.get("sie_v2") or {}
            if isinstance(sie2, dict):
                if "valence_01" in sie2:
                    val2 = sie2.get("valence_01")
                elif "valence" in sie2:
                    try:
                        fv = float(sie2.get("valence"))
                        val2 = (fv + 1.0) / 2.0 if -1.001 <= fv <= 1.001 else fv
                    except Exception:
                        val2 = sie2.get("valence")
    ss.val2.append(val2)
    ss.entro.append(ex.get("connectome_entropy"))


def append_say(ss: SeriesState, rec: Dict[str, Any]):
    name = (rec.get("macro") or rec.get("name") or rec.get("kind") or "").lower()
    if name != "say":
        return
    t = rec.get("t") or rec.get("tick") or rec.get("meta", {}).get("t") or rec.get("meta", {}).get("tick")
    if t is None:
        return
    try:
        ss.speak_ticks.append(int(t))
    except Exception:
        pass


def ffill(arr: List[Any]) -> List[float | None]:
    out: List[float | None] = []
    last: float | None = None
    for x in arr:
        if x is None:
            out.append(last)
        else:
            try:
                v = float(x)
            except Exception:
                v = last
            out.append(v)
            last = v
    return out]]></content>
    </file>
    <file>
      <path>plugins/fum_visualizer_v1/fum_visualizer.py</path>
      <content><![CDATA[# visualizer.py
"""
Copyright © 2025 Justin K. Lietz, Neuroca, Inc. All Rights Reserved.
"""
import matplotlib.pyplot as plt
import numpy as np
import imageio
from tqdm import tqdm
import plotly.graph_objects as go
import scipy.sparse
import os
from FUM_Void_Equations import delta_re_vgsp, delta_gdsp # Import the void dynamics

def void_driven_layout(W, iterations=50, dim=3):
    """
    Computes a node layout using void dynamics for attraction and repulsion.
    This creates a more organic, biologically plausible layout than random placement.
    Handles both dense and sparse matrices.

    Improvements:
    - O(E) attraction accumulation using numpy.add.at (no NxN tensor)
    - Adaptive, sub-sampled repulsion for large N to avoid O(N^2) blowups
    - Step clipping for stability
    """
    num_nodes = W.shape[0]
    pos = np.random.rand(num_nodes, dim)

    # Extract edges and weights from sparse or dense adjacency
    if scipy.sparse.issparse(W):
        rows, cols = W.nonzero()
        weights = W.data
    else:
        rows, cols = np.where(W > 0)
        weights = W[rows, cols]

    rows = np.asarray(rows, dtype=np.int64)
    cols = np.asarray(cols, dtype=np.int64)
    weights = np.asarray(weights, dtype=float)

    for t_idx in range(iterations):
        # Repulsion (adaptive) — base global void pressure
        if num_nodes <= 800:
            delta = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]
            distance = np.linalg.norm(delta, axis=-1) + 1e-9
            repulsive_force = (1.0 / distance) * (1.0 - (1.0 / distance))
            repulsion = np.sum(delta * (repulsive_force / distance)[..., np.newaxis], axis=1)
        else:
            # Subsample for approximate repulsion, re-scale to keep magnitude consistent
            P = min(400, num_nodes)
            idx = np.random.choice(num_nodes, P, replace=False)
            delta_s = pos[:, np.newaxis, :] - pos[idx][np.newaxis, :, :]
            distance_s = np.linalg.norm(delta_s, axis=-1) + 1e-9
            repulsive_force_s = (1.0 / distance_s) * (1.0 - (1.0 / distance_s))
            repulsion = np.sum(delta_s * (repulsive_force_s / distance_s)[..., np.newaxis], axis=1) * (num_nodes / P)

        # Attraction/Repulsion along existing edges (i -> j), governed by Void Dynamics
        attraction = np.zeros_like(pos)
        vec_ij = pos[cols] - pos[rows]  # direction from i to j
        signs = np.sign(weights).astype(float)  # excitatory(+)/inhibitory(-)

        # Time-dynamic void equations
        try:
            gdsp = delta_gdsp(weights, t_idx, use_time_dynamics=True)  # structural pull/closure
        except Exception:
            gdsp = np.array([delta_gdsp(w, t_idx, use_time_dynamics=True) for w in weights], dtype=float)
        try:
            re_vgsp = delta_re_vgsp(np.abs(weights), t_idx, use_time_dynamics=True)  # resonance modulation
        except Exception:
            re_vgsp = np.array([delta_re_vgsp(abs(w), t_idx, use_time_dynamics=True) for w in weights], dtype=float)

        # Normalize absolute synaptic strength and combine with void signals
        abs_w = np.abs(weights).astype(float)
        if abs_w.size and abs_w.max() > 0:
            abs_w = abs_w / (abs_w.max() + 1e-12)

        # Effective magnitude: strong edges + dynamic modulation
        fmag = abs_w * (1.0 + np.abs(gdsp)) * (1.0 + 0.5 * np.abs(re_vgsp))

        # Direction: excitatory pulls together (+), inhibitory pushes apart (-)
        vec_dir = vec_ij * signs[:, np.newaxis]
        forces = vec_dir * fmag[:, np.newaxis]
        np.add.at(attraction, rows, forces)

        # Global repulsion modulation from RE-VGSP (prevents collapse, encourages differentiation)
        repulsion *= (1.0 + 0.1 * float(np.mean(np.abs(re_vgsp)))) if re_vgsp.size else 1.0

        # Update positions with clipping + annealed step size
        update = repulsion + attraction
        norms = np.linalg.norm(update, axis=1) + 1e-12
        cap = np.percentile(norms, 95)
        scale = np.minimum(1.0, cap / norms)
        step = 0.03 * (0.95 ** t_idx)  # anneal for stability
        pos += step * (update * scale[:, np.newaxis])

    # Normalize positions to [0, 1]^dim
    pos -= pos.min(axis=0)
    span = pos.max(axis=0) - pos.min(axis=0) + 1e-9
    pos /= span

    return {i: pos[i] for i in range(num_nodes)}

def void_traverse_graph(W, iterations=100):
    """
    Traverse the entire connectome via the Void Equations and accumulate per-node potentials.
    Returns a dict with:
      - 'node_potential': ndarray (N,) accumulated resonance/closure magnitude per node
      - 'edge_flux': ndarray (M,) final per-edge flux (|delta_re| + |delta_gd|)*|w|
      - 'rows','cols': edge index mapping for 'edge_flux'
    This can be consumed by the SelfImprovementEngine to guide learning.
    """
    import numpy as _np
    import scipy.sparse as _sp

    N = int(W.shape[0])
    if _sp.issparse(W):
        rows, cols = W.nonzero()
        weights = _np.asarray(W.data, dtype=float)
    else:
        Wd = _np.asarray(W)
        rows, cols = _np.where(Wd != 0)
        weights = _np.asarray(Wd[rows, cols], dtype=float)

    node_potential = _np.zeros(N, dtype=float)
    edge_flux = _np.zeros_like(weights, dtype=float)

    for t in range(int(iterations)):
        try:
            re = delta_re_vgsp(_np.abs(weights), t, use_time_dynamics=True)
        except Exception:
            re = _np.array([delta_re_vgsp(abs(w), t, use_time_dynamics=True) for w in weights], dtype=float)
        try:
            gd = delta_gdsp(weights, t, use_time_dynamics=True)
        except Exception:
            gd = _np.array([delta_gdsp(w, t, use_time_dynamics=True) for w in weights], dtype=float)

        flux = (_np.abs(re) + _np.abs(gd)) * _np.maximum(1e-12, _np.abs(weights))
        edge_flux = flux  # keep last (or could accumulate with +=)

        # Deposit flux to target nodes (incoming) and a small portion to source
        _np.add.at(node_potential, cols, flux)
        _np.add.at(node_potential, rows, 0.25 * flux)

    return {
        "node_potential": node_potential,
        "edge_flux": edge_flux,
        "rows": rows,
        "cols": cols,
    }

def plot_network_graph(W, t, title: str, save_path: str, pos: dict, threshold=0.0, node_strength_mode: str = "inout"):
    """
    Creates a 2D visual representation of the FUM's connectome using a pre-calculated layout.
    Renders all connections above a minimal threshold, with transparency based on weight.
    """
    if scipy.sparse.issparse(W):
        W_dense = W.toarray()
    else:
        W_dense = W

    if hasattr(W_dense, 'cpu'):
        W_dense = W_dense.cpu().numpy()
        
    num_nodes = W_dense.shape[0]
    if not pos:
        pos = {i: np.random.rand(2) for i in range(num_nodes)}

    plt.figure(figsize=(12, 12))
    ax = plt.gca()
    
    node_coords = np.array(list(pos.values()))
    # --- Node coloring by synaptic strength (dark blue = strong, light blue = weak) ---
    absW = np.abs(W_dense)
    in_strength = absW.sum(axis=0)
    out_strength = absW.sum(axis=1)
    mode = str(node_strength_mode).lower()
    if mode == "in":
        strengths = in_strength
    elif mode == "out":
        strengths = out_strength
    else:
        strengths = in_strength + out_strength  # default: total in+out strength
    strengths = np.asarray(strengths, dtype=float)
    cmap = plt.get_cmap('Blues')  # light->dark; high (strong) appears darker
    vmin = float(np.min(strengths))
    vmax = float(np.max(strengths)) if np.max(strengths) > vmin else vmin + 1e-9
    norm = plt.Normalize(vmin=vmin, vmax=vmax)
    node_colors = cmap(norm(strengths))
    ax.scatter(node_coords[:, 0], node_coords[:, 1], s=150, color=node_colors, alpha=0.9, zorder=2, edgecolors='white', linewidth=0.5)

    # Correctly handle sparse or dense matrix for edges
    if scipy.sparse.issparse(W):
        rows, cols = W.nonzero()
        weights = W.data
    else:
        rows, cols = np.where(W_dense > threshold)
        weights = W_dense[rows, cols]
        
    valid_weights = weights[weights > 0]
    if len(valid_weights) > 0:
        edge_norm = plt.Normalize(vmin=valid_weights.min(), vmax=valid_weights.max())
    else:
        edge_norm = plt.Normalize(vmin=0, vmax=1) # Fallback

    for i, j, weight in zip(rows, cols, weights):
        if weight <= threshold:
             continue
        edge_color = cmap(edge_norm(weight))
        alpha = max(0.1, min(1.0, weight*2))
        linewidth = max(0.5, weight*3)
        ax.plot([pos[i][0], pos[j][0]], [pos[i][1], pos[j][1]], color=edge_color, alpha=alpha, linewidth=linewidth, zorder=1)
    
    plt.title(title, fontsize=20, color='white')
    plt.axis('off')
    plt.tight_layout()
    fig = plt.gcf()
    fig.set_facecolor('black')
    plt.savefig(save_path, dpi=300, bbox_inches='tight', facecolor='black')
    plt.close()
    print(f"Saved network graph to '{save_path}'")

def plot_spike_raster(spike_times: list, title: str, save_path: str):
    """
    Creates and saves a spike raster plot.
    """
    plt.figure(figsize=(12, 8), facecolor='black')
    ax = plt.gca()
    ax.set_facecolor('black')
    
    plt.eventplot(spike_times, colors='cyan', linelengths=0.75)
    
    plt.title(title, fontsize=20, color='white')
    plt.xlabel("Time (Global Steps)", fontsize=14, color='white')
    plt.ylabel("Computational Unit (CU) ID", fontsize=14, color='white')
    
    ax.spines['bottom'].set_color('white')
    ax.spines['top'].set_color('white') 
    ax.spines['right'].set_color('white')
    ax.spines['left'].set_color('white')
    ax.tick_params(axis='x', colors='white')
    ax.tick_params(axis='y', colors='white')
    
    plt.grid(True, which='both', linestyle='--', linewidth=0.5, color='gray', alpha=0.3)
    plt.tight_layout()
    plt.savefig(save_path, dpi=300, facecolor='black')
    plt.close()
    print(f"Saved spike raster plot to '{save_path}'")

def create_maze_animation(maze_layout: np.ndarray, goal_pos: tuple, path: list, title: str, save_path: str):
    """
    Creates an animated GIF of the agent's path through a maze.
    This function is for specific experiments and is not part of the core FUM.
    """
    if not path:
        print("Warning: Cannot create animation for an empty path.")
        return
        
    frames = []
    for i in tqdm(range(len(path)), desc="Generating Animation Frames"):
        fig, ax = plt.subplots(figsize=(8, 6), facecolor='black')
        ax.set_facecolor('black')
        
        ax.imshow(maze_layout, cmap='Greys', interpolation='nearest')
        
        goal_patch = plt.Rectangle((goal_pos[1] - 0.5, goal_pos[0] - 0.5), 1, 1, color='gold', alpha=0.9)
        ax.add_patch(goal_patch)

        if i > 0:
            path_arr = np.array(path[:i+1])
            ax.plot(path_arr[:, 1], path_arr[:, 0], color='cyan', linewidth=2.5, alpha=0.7)

        agent_patch = plt.Circle((path[i][1], path[i][0]), radius=0.3, color='red')
        ax.add_patch(agent_patch)

        ax.set_title(f"{title}\nStep: {i+1}/{len(path)}", fontsize=16, color='white')
        ax.set_xticks([])
        ax.set_yticks([])
        
        fig.canvas.draw()
        frame = np.array(fig.canvas.renderer.buffer_rgba())
        frames.append(frame)
        plt.close(fig)

    imageio.mimsave(save_path, frames, fps=max(10, len(path)//10))
    print(f"Saved animation to '{save_path}'")

def plot_3d_network_graph(
    W,
    t,
    title: str,
    save_path: str,
    pos: dict,
    threshold=0.0,
    edge_bins: int = 4,
    edge_style: str = "gray",          # "gray" for classic brain look, "blues" for weight-binned blues
    save_png: bool = True,             # also write a static PNG via kaleido
    camera: dict | None = None,        # optional plotly camera dict
    node_size: int = 7,
    node_opacity: float = 0.9
):
    """
    Creates an interactive 3D visual representation of the FUM's connectome using Plotly.
    Upgrades:
    - Consolidates edges into a small number of traces (binned by weight) for faster rendering.
    - Optional classic brain styling: light-blue nodes with soft gray edges.
    - Saves BOTH an interactive HTML and a high-res PNG (requires 'kaleido').
    """
    # Ensure a dense array for node metrics only; edges are drawn from original W
    if scipy.sparse.issparse(W):
        W_dense = W.toarray()
    else:
        W_dense = W

    if hasattr(W_dense, 'cpu'):
        W_dense = W_dense.cpu().numpy()

    num_nodes = W_dense.shape[0]
    if not pos:
        pos = {i: np.random.rand(3) for i in range(num_nodes)}

    # --- Nodes (colored by incoming strength) ---
    node_coords = np.array(list(pos.values()))
    # Node color encodes synaptic strength (dark=strong, light=weak)
    absW = np.abs(W_dense)
    in_strength = absW.sum(axis=0)
    out_strength = absW.sum(axis=1)
    strengths = (in_strength + out_strength).astype(float)
    vmin = float(np.min(strengths))
    vmax = float(np.max(strengths)) if np.max(strengths) > vmin else vmin + 1e-9
    node_trace = go.Scatter3d(
        x=node_coords[:, 0], y=node_coords[:, 1], z=node_coords[:, 2],
        mode='markers',
        marker=dict(
            size=int(node_size),
            color=strengths,
            colorscale='Blues',
            cmin=vmin,
            cmax=vmax,
            showscale=True,
            colorbar=dict(title='Synapse Strength'),
            opacity=float(node_opacity),
        ),
        hoverinfo='text',
        text=[f'Neuron {i}<br>Syn Strength: {strengths[i]:.2f}' for i in range(num_nodes)],
    )

    # --- Edges: build in a handful of weight bins for speed ---
    if scipy.sparse.issparse(W):
        rows, cols = W.nonzero()
        weights = np.asarray(W.data, dtype=float)
    else:
        rows, cols = np.where(W_dense > threshold)
        weights = np.asarray(W_dense[rows, cols], dtype=float)

    # Filter by threshold
    mask = weights > float(threshold)
    rows, cols, weights = rows[mask], cols[mask], weights[mask]

    edge_traces = []
    if len(weights) > 0:
        # Compute bin edges (quantiles); fall back to single-bin if all weights equal
        try:
            qs = np.linspace(0.0, 1.0, num=max(2, edge_bins + 1))
            bin_edges = np.quantile(weights, qs)
            # Ensure strictly increasing (handle degenerate distributions)
            bin_edges = np.unique(bin_edges)
        except Exception:
            bin_edges = np.array([weights.min(), weights.max()])

        # If degenerate, just one bin
        if bin_edges.size <= 1:
            bin_edges = np.array([float(weights.min()), float(weights.max() + 1e-9)])

        # Edge color palette
        if str(edge_style).lower() == "gray":
            # Classic brain style: soft gray edges with increasing opacity
            palette = [
                'rgba(170, 170, 170, 0.22)',
                'rgba(170, 170, 170, 0.30)',
                'rgba(170, 170, 170, 0.40)',
                'rgba(170, 170, 170, 0.52)',
                'rgba(170, 170, 170, 0.65)',
            ]
        else:
            # Pastel blues (light to brighter)
            palette = [
                'rgba(135, 206, 235, 0.35)',  # light skyblue
                'rgba(100, 149, 237, 0.5)',   # cornflower
                'rgba(65, 105, 225, 0.65)',   # royalblue
                'rgba(30, 144, 255, 0.8)',    # dodgerblue
                'rgba(0, 191, 255, 0.9)',     # deepskyblue
            ]

        # Build one trace per bin with None-separated line segments
        for b in range(bin_edges.size - 1):
            lo, hi = bin_edges[b], bin_edges[b + 1]
            # Include the upper edge for the last bin
            in_bin = (weights >= lo) & (weights <= hi if b == bin_edges.size - 2 else weights < hi)
            if not np.any(in_bin):
                continue
            r_b = rows[in_bin]
            c_b = cols[in_bin]

            edge_x, edge_y, edge_z = [], [], []
            for i, j in zip(r_b, c_b):
                edge_x.extend([pos[i][0], pos[j][0], None])
                edge_y.extend([pos[i][1], pos[j][1], None])
                edge_z.extend([pos[i][2], pos[j][2], None])

            color = palette[min(b, len(palette) - 1)]
            width = max(1.0, 1.0 + 0.6 * (b + 1))
            edge_traces.append(
                go.Scatter3d(
                    x=edge_x, y=edge_y, z=edge_z,
                    mode='lines',
                    line=dict(color=color, width=width),
                    hoverinfo='none',
                    showlegend=False,
                )
            )

    # --- Compose figure ---
    fig = go.Figure(data=edge_traces + [node_trace])
    fig.update_layout(
        title=dict(text=title, font=dict(size=20, color='white')),
        showlegend=False,
        scene=dict(
            xaxis=dict(showbackground=False, showticklabels=False, title=''),
            yaxis=dict(showbackground=False, showticklabels=False, title=''),
            zaxis=dict(showbackground=False, showticklabels=False, title=''),
            bgcolor='black',
        ),
        margin=dict(l=0, r=0, b=0, t=40),
        paper_bgcolor='black',
        font_color='white',
    )
    # Set a pleasant default camera if none provided
    if camera is None:
        camera = dict(eye=dict(x=1.6, y=1.6, z=0.9))
    fig.update_layout(scene_camera=camera)

    # Save as interactive HTML
    html_save_path = save_path.replace('.png', '.html')
    fig.write_html(html_save_path)
    print(f"Saved interactive 3D network graph to '{html_save_path}'")

    # Optionally save a high-res PNG using kaleido
    if save_png and save_path.lower().endswith(".png"):
        try:
            # Width/height chosen for publication-quality output
            fig.write_image(save_path, format="png", width=1920, height=1200, scale=2)
            print(f"Saved static 3D network graph PNG to '{save_path}'")
        except Exception as e:
            print(f"[WARN] Could not save PNG to '{save_path}'. Install 'kaleido' to enable static image export. Error: {e}")

def export_connectome_json(W, pos, path, threshold=0.0):
    """
    Export adjacency and node positions to a JSON schema for front-end visualization.

    - Handles scipy.sparse and dense matrices
    - Accepts pos as a dict {node_id: [x,y,(z)?]} or ndarray shape (N, D)
    - Applies a weight threshold (exclusive) to filter edges

    JSON schema (FUM.connectome.v1):
    {
      "schema": "FUM.connectome.v1",
      "directed": true,
      "num_nodes": N,
      "num_edges": M,
      "threshold": float,
      "nodes": [{ "id": int, "pos": [x,y,(z)?] }, ...],
      "edges": [{ "source": int, "target": int, "weight": float }, ...]
    }
    """
    import json
    import numpy as _np
    import scipy.sparse as _sp

    num_nodes = int(W.shape[0])

    # Build nodes with positions
    nodes = []
    if isinstance(pos, dict):
        for i in range(num_nodes):
            coords = pos.get(i)
            if coords is None:
                coords = _np.random.rand(2)
            coords = _np.asarray(coords).tolist()
            nodes.append({"id": i, "pos": coords})
    else:
        pos_arr = _np.asarray(pos)
        for i in range(num_nodes):
            coords = pos_arr[i].tolist()
            nodes.append({"id": i, "pos": coords})

    # Extract edges
    if _sp.issparse(W):
        rows, cols = W.nonzero()
        weights = W.data
    else:
        W_dense = _np.asarray(W)
        rows, cols = _np.where(W_dense > threshold)
        weights = W_dense[rows, cols]

    edges = []
    for i, j, w in zip(rows, cols, weights):
        if w <= threshold:
            continue
        edges.append({"source": int(i), "target": int(j), "weight": float(w)})

    payload = {
        "schema": "FUM.connectome.v1",
        "directed": True,
        "num_nodes": num_nodes,
        "num_edges": len(edges),
        "threshold": float(threshold),
        "nodes": nodes,
        "edges": edges,
    }

    with open(path, "w") as f:
        json.dump(payload, f)

    print(f"Saved connectome JSON to '{path}'")


def export_connectome_npz(W, path):
    """
    Persist the connectome to NPZ (CSR) for exact reconstruction later.
    """
    import scipy.sparse as _sp
    from scipy.sparse import csr_matrix as _csr

    W_csr = W if _sp.issparse(W) else _csr(W)
    _sp.save_npz(path, W_csr)
    print(f"Saved connectome NPZ to '{path}'")]]></content>
    </file>
    <file>
      <path>services/process_manager.py</path>
      <content><![CDATA[import os
import sys
import time
import threading
import subprocess
from typing import Any, Dict, List, Tuple


class ProcessManager:
    """
    Extracted from the dashboard without behavior changes.
    Launches python -m fum_rt.run_nexus with a profile, manages stdin feeding, and exposes launcher log.
    """

    def __init__(self, runs_root: str):
        # Persist UI-configured runs root and normalize to absolute path
        self.runs_root = runs_root
        self.runs_root_abs = os.path.abspath(runs_root)
        # Ensure runs_root exists and store repo root for module resolution
        try:
            os.makedirs(self.runs_root_abs, exist_ok=True)
        except Exception:
            pass
        # Resolve repository root (directory that contains the 'fum_rt' package)
        # so 'python -m fum_rt.run_nexus' works even when runs_root is outside repo.
        # services -> frontend -> fum_rt -> REPO_ROOT
        self.repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", ".."))
        # Launch logging (so you can inspect startup failures)
        self.launch_log = os.path.join(self.runs_root_abs, "launcher_last.log")
        self._logf = None
        self.last_cmd: List[str] | None = None

        self.proc: subprocess.Popen | None = None
        self.proc_lock = threading.Lock()
        self.current_run_dir: str | None = None
        self._stdin_lock = threading.Lock()
        self._feed_thread: threading.Thread | None = None
        self._feed_stop = threading.Event()
        # Instrumentation for run-dir detection
        self.last_detect_ms: float = 0.0
        self.last_detect_method: str = "init"
        self.last_cwd: str | None = None

    def set_runs_root(self, root: str):
        """Update runs root to match UI selection and rotate launch log path."""
        try:
            self.runs_root = root
            self.runs_root_abs = os.path.abspath(root)
            os.makedirs(self.runs_root_abs, exist_ok=True)
        except Exception:
            pass
        try:
            self.launch_log = os.path.join(self.runs_root_abs, "launcher_last.log")
        except Exception:
            pass

    def _build_cmd(self, profile: Dict[str, Any]) -> List[str]:
        py = sys.executable or "python"
        cmd = [py, "-m", "fum_rt.run_nexus"]

        def add(flag: str, val: Any, cast=str):
            if val is None:
                return
            cmd.extend([flag, cast(val)])

        # basic
        add("--neurons", profile.get("neurons"), str)
        add("--k", profile.get("k"), str)
        add("--hz", profile.get("hz"), str)
        add("--domain", profile.get("domain"), str)
        if profile.get("use_time_dynamics", True):
            cmd.append("--use-time-dynamics")
        else:
            cmd.append("--no-time-dynamics")
        # sparse / structure
        if profile.get("sparse_mode", False):
            cmd.append("--sparse-mode")
        add("--threshold", profile.get("threshold"), str)
        add("--lambda-omega", profile.get("lambda_omega"), str)
        add("--candidates", profile.get("candidates"), str)
        add("--walkers", profile.get("walkers"), str)
        add("--hops", profile.get("hops"), str)
        add("--status-interval", profile.get("status_interval"), str)
        add("--bundle-size", profile.get("bundle_size"), str)
        add("--prune-factor", profile.get("prune_factor"), str)
        # stim
        add("--stim-group-size", profile.get("stim_group_size"), str)
        add("--stim-amp", profile.get("stim_amp"), str)
        add("--stim-decay", profile.get("stim_decay"), str)
        add("--stim-max-symbols", profile.get("stim_max_symbols"), str)
        # speak
        if profile.get("speak_auto", True):
            cmd.append("--speak-auto")
        else:
            cmd.append("--no-speak-auto")
        add("--speak-z", profile.get("speak_z"), str)
        add("--speak-hysteresis", profile.get("speak_hysteresis"), str)
        add("--speak-cooldown-ticks", profile.get("speak_cooldown_ticks"), str)
        add("--speak-valence-thresh", profile.get("speak_valence_thresh"), str)
        add("--b1-half-life-ticks", profile.get("b1_half_life_ticks"), str)
        # viz/log
        add("--viz-every", profile.get("viz_every"), str)
        add("--log-every", profile.get("log_every"), str)
        # checkpoints
        add("--checkpoint-every", profile.get("checkpoint_every"), str)
        add("--checkpoint-keep", profile.get("checkpoint_keep"), str)
        add("--duration", profile.get("duration"), str)
        # explicit run dir (resume)
        add("--run-dir", profile.get("run_dir"), str)
        # optional: load existing engram (folder or file path; runtime normalizes)
        if profile.get("load_engram"):
            cmd.extend(["--load-engram", str(profile["load_engram"])])
        return cmd

    def start(self, profile: Dict[str, Any]) -> Tuple[bool, str]:
        with self.proc_lock:
            if self.proc and self.proc.poll() is None:
                return False, "Already running"

            # Normalize runs root and ensure it exists
            rr = getattr(self, "runs_root_abs", None) or os.path.abspath(self.runs_root)
            try:
                os.makedirs(rr, exist_ok=True)
            except Exception:
                pass
            before = set(os.listdir(rr)) if os.path.exists(rr) else set()
            detection_t0 = time.time()

            # Ensure explicit run_dir honors UI-selected runs_root on fresh starts.
            # If the profile does not specify run_dir (i.e., Start New Run without adoption),
            # synthesize runs_root/<timestamp> to avoid defaulting to 'runs/<ts>' regardless of UI choice.
            if not profile.get("run_dir"):
                try:
                    ts = time.strftime('%Y%m%d_%H%M%S')
                    profile["run_dir"] = os.path.join(rr, ts)
                except Exception:
                    pass

            cmd = self._build_cmd(profile)
            self.last_cmd = cmd[:]

            # Prepare environment so 'python -m fum_rt.run_nexus' resolves even if GUI was launched elsewhere
            env = os.environ.copy()
            try:
                repo_root = self.repo_root
            except Exception:
                repo_root = os.path.dirname(os.path.abspath(__file__))
            env["PYTHONPATH"] = f"{repo_root}:{env.get('PYTHONPATH','')}"
            env.setdefault("PYTHONUNBUFFERED", "1")

            # open launch log so we can surface failures
            try:
                if self._logf:
                    try:
                        self._logf.close()
                    except Exception:
                        pass
                self._logf = open(self.launch_log, "wb")
            except Exception:
                self._logf = None

            # Run from parent dir of runs_root so runtime writes to rr = <parent>/runs
            cwd_dir = os.path.dirname(rr)
            try:
                self.proc = subprocess.Popen(
                    cmd,
                    stdin=subprocess.PIPE,
                    stdout=self._logf or subprocess.DEVNULL,
                    stderr=self._logf or subprocess.DEVNULL,
                    cwd=cwd_dir,
                    env=env
                )
            except Exception as e:
                self.proc = None
                return False, f"Failed to start: {e}"

            # If the process died immediately, surface the log
            time.sleep(0.5)
            if self.proc and self.proc.poll() is not None:
                try:
                    if self._logf:
                        self._logf.flush()
                        self._logf.close()
                        self._logf = None
                    with open(self.launch_log, "rb") as fh:
                        tail = fh.read()[-4096:]
                    return False, f"Process exited during start.\nCommand: {' '.join(cmd)}\nLog({self.launch_log}):\n{tail.decode('utf-8','ignore')}"
                except Exception:
                    return False, f"Process exited during start.\nCommand: {' '.join(cmd)}\nNo launch log available."

            # Resolve run dir with instrumentation
            run_dir = None
            detect_method = None
            specified = profile.get("run_dir")
            if specified:
                run_dir = str(specified)
                detect_method = "explicit"
            else:
                # Detect new run dir (robust loop)
                for _ in range(20):  # ~5s total
                    try:
                        after = set(os.listdir(rr)) if os.path.exists(rr) else set()
                        new_dirs = list(after - before)
                        if new_dirs:
                            run_dir = max(
                                (os.path.join(rr, d) for d in new_dirs),
                                key=lambda p: os.path.getmtime(p)
                            )
                            detect_method = "create_watch"
                            break
                    except Exception:
                        pass
                    time.sleep(0.25)

                if not run_dir:
                    # fallback: latest by mtime under runs_root
                    runs = sorted(
                        [os.path.join(rr, d) for d in os.listdir(rr) if os.path.isdir(os.path.join(rr, d))],
                        key=lambda p: os.path.getmtime(p),
                        reverse=True
                    ) if os.path.exists(rr) else []
                    run_dir = runs[0] if runs else None
                    detect_method = "fallback_latest" if run_dir else "none"

            # Record detection diagnostics and surface to launcher log
            try:
                self.last_detect_ms = float((time.time() - detection_t0) * 1000.0)
            except Exception:
                self.last_detect_ms = 0.0
            self.last_detect_method = detect_method or "unknown"
            try:
                self.last_cwd = cwd_dir
            except Exception:
                self.last_cwd = None
            try:
                if self._logf:
                    line = f"[UI] run_dir_detected method={self.last_detect_method} ms={int(self.last_detect_ms)} rd={run_dir or ''} rr={rr} cwd={cwd_dir}\n"
                    self._logf.write(line.encode("utf-8", "ignore"))
                    self._logf.flush()
            except Exception:
                pass

            self.current_run_dir = run_dir
            return True, run_dir or ""

    def stop(self) -> Tuple[bool, str]:
        with self.proc_lock:
            if not self.proc:
                return False, "Not running"
            try:
                self.proc.terminate()
                try:
                    self.proc.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.proc.kill()
            except Exception as e:
                return False, f"Stop error: {e}"
            finally:
                self.proc = None
                self.current_run_dir = None
                try:
                    if self._logf:
                        self._logf.close()
                        self._logf = None
                except Exception:
                    pass
            return True, "Stopped"

    def send_line(self, text: str) -> bool:
        with self.proc_lock:
            if not self.proc or self.proc.stdin is None:
                return False
            try:
                with self._stdin_lock:
                    self.proc.stdin.write((text.rstrip("\n") + "\n").encode("utf-8"))
                    self.proc.stdin.flush()
                return True
            except Exception:
                return False

    def feed_file(self, path: str, rate_lps: float = 20.0):
        if not os.path.exists(path):
            return False
        if not self.proc or self.proc.stdin is None:
            return False
        if self._feed_thread and self._feed_thread.is_alive():
            return False
        self._feed_stop.clear()

        def _runner():
            try:
                with open(path, "r", encoding="utf-8") as fh:
                    for line in fh:
                        if self._feed_stop.is_set():
                            break
                        ok = self.send_line(line)
                        if not ok:
                            break
                        time.sleep(1.0 / max(1e-3, rate_lps))
            except Exception:
                pass

        self._feed_thread = threading.Thread(target=_runner, daemon=True)
        self._feed_thread.start()
        return True

    def stop_feed(self):
        self._feed_stop.set()]]></content>
    </file>
    <file>
      <path>services/status_client.py</path>
      <content><![CDATA[from __future__ import annotations

"""
Lightweight HTTP status client (frontend-only; zero file IO).

- Purpose: fetch the latest runtime status snapshot from the in-process HTTP endpoint
  to drive live dashboard charts without scanning or tailing JSONL files.
- Endpoint (served by runtime.helpers.status_http.maybe_start_status_http):
  GET /status  -> 200 JSON (latest nx._emit_last_metrics) or 204 when not ready
  GET /health  -> 200 {"ok": true}

Environment
- STATUS_HTTP_URL (default "http://127.0.0.1:8787/status")
- STATUS_HTTP_TIMEOUT_MS (default 200)

Contracts
- Returns a Python dict on HTTP 200 with valid JSON; None on 204 or any error.
- No retries, no background threads; caller controls cadence (e.g., via dcc.Interval).
"""

import os
import json
from typing import Any, Optional
import urllib.request
import urllib.error


def get_status_snapshot(url: Optional[str] = None, timeout_s: Optional[float] = None) -> Optional[dict[str, Any]]:
    """
    Fetch the latest status snapshot.

    Args:
        url: Optional override for status URL (e.g., "http://127.0.0.1:8787/status/snapshot").
             If None, use env STATUS_HTTP_URL or default "http://127.0.0.1:8787/status".
        timeout_s: Optional override for request timeout in seconds. If None, use env
                   STATUS_HTTP_TIMEOUT_MS (default 0.2s).

    Returns:
        dict[str, Any] on success (HTTP 200 JSON)
        None on 204 or any error/parse failure
    """
    # URL
    if url is None:
        try:
            url = os.getenv("STATUS_HTTP_URL", "http://127.0.0.1:8787/status").strip() or "http://127.0.0.1:8787/status"
        except Exception:
            url = "http://127.0.0.1:8787/status"
    # Prefer /status/snapshot if caller passed base /status
    try:
        if url.endswith("/status"):
            url = url + "/snapshot"
    except Exception:
        pass

    # Timeout
    if timeout_s is None:
        try:
            tms = int(os.getenv("STATUS_HTTP_TIMEOUT_MS", "200"))
        except Exception:
            tms = 200
        timeout_s = max(0.05, float(tms) / 1000.0)
    else:
        try:
            timeout_s = max(0.05, float(timeout_s))
        except Exception:
            timeout_s = 0.2

    try:
        req = urllib.request.Request(url, headers={"Accept": "application/json"})
        with urllib.request.urlopen(req, timeout=timeout_s) as resp:  # nosec B310 (local loopback by default)
            code = getattr(resp, "status", 200)
            if code == 204:
                return None
            data = resp.read()
            if not data:
                return None
            try:
                return json.loads(data.decode("utf-8", "ignore"))
            except Exception:
                return None
    except (urllib.error.URLError, urllib.error.HTTPError, TimeoutError, OSError):
        return None
    except Exception:
        return None


__all__ = ["get_status_snapshot"]]]></content>
    </file>
    <file>
      <path>styles/README.md</path>
      <content><![CDATA[# FUM Frontend Styles (Modular)

This package provides a modular CSS system for the Dash UI. Instead of a single monolithic CSS string, styles are layered and composed at runtime in a stable order.

Layering contract:
1) base: variables, resets, typography, form controls, scrollbars (no layout)
2) layout: grids, cards, responsive rules, utilities (no component overrides)
3) components: dcc.Dropdown/react-select, rc-slider, and component-specific rules

Exported API:
- from fum_rt.frontend.styles import get_global_css
- from fum_rt.frontend.styles import get_base_css, get_layout_css, get_components_css

## Usage

Inject the CSS into Dash index_string (already wired in app.py):

```python
from fum_rt.frontend.styles import get_global_css

GLOBAL_CSS = get_global_css()
app.index_string = app.index_string.replace("</head>", f"<style>{GLOBAL_CSS}</style></head>")
```

If legacy imports are still present elsewhere:
```python
# Backward compatible shim
from fum_rt.frontend.styles.theme import get_global_css
```
The shim forwards to the modular aggregator.

## Why modular?

- Separation of concerns:
  - base is safe, foundational, and broadly applicable
  - layout organizes structure and responsiveness
  - components encapsulate third‑party widget tweaks (react-select, rc-slider)
- Lower coupling: view-specific changes can be added without touching core layers
- Fewer regressions: targeted updates reduce incidental style bleed

## Files

- base.py
  - get_base_css(): CSS variables, resets, typography, form controls, scrollbars
- layout.py
  - get_layout_css(): grid/card/row utilities, responsive rules, minor layout helpers (e.g., .tight)
- components.py
  - get_components_css(): dropdown (react-select) and rc-slider styling, layering fixes (z-index), clipping fixes

- __init__.py
  - get_global_css(): concatenates base → layout → components in a fail-soft manner

- theme.py (deprecated shim)
  - Keeps old import path working by delegating to styles.get_global_css

## Adding view-specific styles

For a new view or composite component, there are two options:

1) Extend components.py (small and generic additions)
   - Ideal for adding minor UI polish or tweaking existing component rules.

2) Create a new module and opt-in at composition time
   - Create a new file (e.g., view_run_config.py) next to existing layers with:
     ```python
     def get_run_config_view_css() -> str:
         return '''
         /* styles specific to the run-config view */
         .run-config-advanced {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
             gap: 12px;
         }
         '''
     ```
   - Then import and append in __init__.py as a new layer after components:
     ```python
     from .view_run_config import get_run_config_view_css
     ...
     layers = [get_base_css, get_layout_css, get_components_css, get_run_config_view_css]
     ```
   - Keep the rule of thumb: more specific layers later in the list.

Note: If you expect multiple view-specific files, consider a subpackage (e.g., styles/views/) with a local __init__.py to assemble view layers, then include that combined view CSS at the end of the main list.

## Conventions and constraints

- No global scans, no schedulers: All CSS is static strings concatenated at build/start time.
- Respect existing className contracts in layout (e.g., className="grid").
- Keep base.css free of layout or component specifics to minimize interactions.
- Layout should not override third‑party components; that belongs in components.py.
- Use z-index sparingly; menu portals (react-select) need to sit above cards. This is handled in components.py.

## Responsive decisions (summary)

- The grid defaults to minmax(300px, 360px) 1fr for two-column layouts, with breakpoints:
  - ≤1200px: left column narrows slightly
  - ≤900px: stacks to a single column
- Cards allow overflow: visible for dropdowns and menus (prevents clipping).
- Inputs and long text are clamped with max-width: 100% to prevent layout shifts.

## Duplicate rule sanity

- By design, base/layout/components do not duplicate selectors with conflicting declarations.
- If you add view-specific rules, keep selector specificity scoped (e.g., prefix with a container class for the view) to avoid broad overrides.
- In case of an intentional override, place it later in the layer order.

## Example: switching from legacy

Before:
```python
from fum_rt.frontend.styles.theme import get_global_css
```

After (preferred):
```python
from fum_rt.frontend.styles import get_global_css
```

Legacy imports continue to function via the shim.

## Governance

- Any proposal to add a new layer must justify why existing layers cannot host the rules.
- Maintain the base → layout → components → views ordering to preserve determinism.
- Target changes to the minimal layer that owns the concern.

Author: Justin K. Lietz]]></content>
    </file>
    <file>
      <path>styles/__init__.py</path>
      <content><![CDATA["""
FUM Frontend Styles (modular)

Exports:
- get_global_css(): concatenates base → layout → components CSS in a safe order
- get_base_css, get_layout_css, get_components_css: individual layers (advanced usage)

Layering contract:
1) base: variables, resets, typography, form controls, scrollbars (no layout)
2) layout: grids, cards, responsive rules, utilities (no component overrides)
3) components: dcc.Dropdown/react-select, rc-slider, and component-specific rules

Author: Justin K. Lietz
"""

from __future__ import annotations

from typing import Callable, List

# Individual layers
try:
    from .base import get_base_css
except Exception:  # pragma: no cover
    def get_base_css() -> str:  # type: ignore[no-redef]
        return ""

try:
    from .layout import get_layout_css
except Exception:  # pragma: no cover
    def get_layout_css() -> str:  # type: ignore[no-redef]
        return ""

try:
    from .components import get_components_css
except Exception:  # pragma: no cover
    def get_components_css() -> str:  # type: ignore[no-redef]
        return ""


def get_global_css() -> str:
    """
    Return the full CSS string for injection into Dash index.
    Concatenates in stable order: base → layout → components.
    Robust to partial availability (missing modules return empty string).
    """
    layers: List[Callable[[], str]] = [get_base_css, get_layout_css, get_components_css]
    parts: List[str] = []
    for layer in layers:
        try:
            css = layer()
            if css and isinstance(css, str):
                parts.append(css)
        except Exception:
            # Fail-soft: do not crash the app if one layer errors
            continue
    return "\n".join(parts)


__all__ = [
    "get_global_css",
    "get_base_css",
    "get_layout_css",
    "get_components_css",
]]]></content>
    </file>
    <file>
      <path>styles/base.py</path>
      <content><![CDATA["""
Base CSS for FUM Live Dashboard.

Modularized: foundational variables, typography, resets, form controls, scrollbars.
Include this first; layer layout- and component-specific CSS on top.

Author: Justin K. Lietz
"""

from __future__ import annotations

def get_base_css() -> str:
    """
    Return core CSS variables and base elements without layout or component rules.
    Safe to include standalone; other style modules should be appended after this.
    """
    return """
    :root{
      --bg:#0b0f14; --panel:#10151c; --panel2:#0e141a; --text:#cfd7e3; --muted:#8699ac;
      --accent:#6aa0c2; --ok:#3a8f5c; --danger:#b3565c; --border:#1d2733; --grid:#233140;
      --plot:#0f141a; --paper:#10151c;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    html{scrollbar-gutter: stable both-edges}
    body{background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica Neue,Arial,Noto Sans,sans-serif;line-height:1.35;margin:0}
    h1,h2,h3,h4{color:var(--text);font-weight:600;margin:0 0 8px 0}
    p{margin:0 0 8px 0}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}

    label{font-size:12px;color:var(--muted);margin-bottom:4px;display:block}

    button{cursor:pointer;border-radius:8px;border:1px solid var(--border);padding:6px 10px;background:var(--panel2);color:var(--text)}
    button:hover{filter:brightness(1.05)}
    .btn-ok{background:var(--ok);color:#fff;border:none}
    .btn-danger{background:var(--danger);color:#fff;border:none}

    pre{background:#0a0e13;border:1px solid var(--border);border-radius:8px;padding:8px;white-space:pre-wrap;color:#dfe7f1}
    input[type="text"],input[type="number"],textarea,select{
        width:100%;background:var(--panel2);color:var(--text);border:1px solid var(--border);
        border-radius:8px;padding:6px 8px;outline:none;
    }
    input::placeholder,textarea::placeholder{color:var(--muted)}
    input:focus,textarea:focus,select:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(106,160,194,0.15)}

    /* Scrollbars (WebKit) */
    *::-webkit-scrollbar{width:10px;height:10px}
    *::-webkit-scrollbar-track{background:var(--panel)}
    *::-webkit-scrollbar-thumb{
        background:#1d2733;
        border-radius:8px;
        border:1px solid var(--grid);
    }
    *::-webkit-scrollbar-thumb:hover{background:#273445}

    /* Scrollbars (Firefox) */
    *{scrollbar-color:#1d2733 var(--panel2);scrollbar-width:thin}
    """]]></content>
    </file>
    <file>
      <path>styles/components.py</path>
      <content><![CDATA["""
Component CSS for FUM Live Dashboard.

Modularized: dcc.Dropdown (react-select), rc-slider, and component-level utilities.
Include after styles.layout.get_layout_css().

Author: Justin K. Lietz
"""

from __future__ import annotations


def get_components_css() -> str:
    """
    Return component-specific rules for dropdowns, sliders, etc.
    """
    return """
    /* dcc.Dropdown (react-select) */
    .Select-control{
      background:var(--panel2)!important;
      border:1px solid var(--border)!important;
      color:var(--text)!important;
      border-radius:8px;
      min-height: 34px;
    }
    .Select--single>.Select-control .Select-value{
      color:var(--text)!important;
    }
    .Select-menu-outer{
      background:var(--panel2)!important;
      border:1px solid var(--border)!important;
      color:var(--text)!important;
      z-index: 9999 !important; /* ensure above neighbors */
    }
    .Select-option{
      background:var(--panel2)!important;
      color:var(--text)!important;
    }
    .Select-option.is-focused{background:#121a22!important}
    .Select-option.is-selected{background:#17222c!important}
    .VirtualizedSelectFocusedOption{background:#121a22!important}

    /* Prevent clipping of dropdown menus by container overflow */
    .dash-dropdown, .Select, .Select-menu-outer{
      overflow: visible !important;
    }

    /* Ensure focus rings render above adjacent inputs */
    .Select-control{ z-index: 2 }

    /* rc-slider */
    .rc-slider{padding:8px 0; z-index: 1}
    .rc-slider-rail{background:#0d1218}
    .rc-slider-track{background:var(--accent)}
    .rc-slider-dot{border-color:#233140;background:#10151c}
    .rc-slider-handle{border:1px solid var(--border);background:var(--panel2)}
    """]]></content>
    </file>
    <file>
      <path>styles/layout.py</path>
      <content><![CDATA["""
Layout CSS for FUM Live Dashboard.

Modularized: grid system, card container, responsive rules, utilities.
Include after styles.base.get_base_css().

Author: Justin K. Lietz
"""

from __future__ import annotations

def get_layout_css() -> str:
    """
    Return responsive layout rules (no component styling).
    """
    return """
    /* Layout hardening and responsive behavior */

    /* Constrain the app container to avoid full-width stretch on huge monitors */
    #react-entry-point, #_dash-app-content, #_dash-app-content > div{
      max-width: 1600px;
      margin: 0 auto;
      width: 100%;
    }

    /* Improve base grid: use a flexible left column and maintain gap consistency */
    .grid{
      display: grid;
      grid-template-columns: minmax(300px, 360px) 1fr;
      gap: 16px;
      align-items: start;
    }

    /* On mid-sized screens, ease the left column width to reduce crowding */
    @media (max-width: 1200px){
      .grid{
        grid-template-columns: minmax(260px, 320px) 1fr;
        gap: 14px;
      }
    }

    /* On narrow screens, stack to a single column to prevent overlap */
    @media (max-width: 900px){
      .grid{
        grid-template-columns: 1fr;
        gap: 12px;
      }
    }

    /* Cards: allow inner components to overflow (e.g., dropdown menus), add column flow */
    .card{
      position: relative;
      overflow: visible; /* prevent dropdown clipping */
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* Utility rows/columns for consistent spacing */
    .row{ display: flex; gap: 8px; flex-wrap: wrap }
    .row > div{ flex: 1; min-width: 140px }
    @media (max-width: 900px){
      .row{ gap: 6px }
      .row > div{ min-width: 120px }
    }

    /* Prevent horizontal scrolling from wide pre/code blocks or long text inputs */
    .card pre, .card code, .card textarea{
      max-width: 100%;
      overflow: auto;
    }

    /* Buttons spacing in cards */
    .card .btn-row{
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    /* Guard against accidental absolute children overlap by default */
    .card > *{
      position: relative;
    }

    /* Optional helper: grid variant that auto-fits equal-width cards */
    .grid-auto{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      align-items: start;
    }

    .tight{ margin-top: 6px }

    /* Tweak focus ring thickness on small screens to reduce visual 'chunkiness' */
    @media (max-width: 900px){
      input:focus, textarea:focus, select:focus{
        box-shadow: 0 0 0 2px rgba(106,160,194,0.15);
      }
    }
    """]]></content>
    </file>
    <file>
      <path>styles/theme.py</path>
      <content><![CDATA["""
Deprecated shim for FUM Frontend Styles.

Old path (legacy):
  from fum_rt.frontend.styles.theme import get_global_css

New canonical path:
  from fum_rt.frontend.styles import get_global_css

This module delegates to the modular styles package to preserve backward compatibility.
"""

from __future__ import annotations

# Prefer aggregator in styles/__init__.py
try:
    from . import get_global_css as _get_global_css  # type: ignore[attr-defined]
except Exception:
    # Fail-soft: compute by concatenating available layers
    def _safe(layer):
        try:
            return layer()
        except Exception:
            return ""

    def _get_global_css() -> str:
        try:
            from .base import get_base_css  # type: ignore
        except Exception:
            def get_base_css() -> str:  # type: ignore[no-redef]
                return ""
        try:
            from .layout import get_layout_css  # type: ignore
        except Exception:
            def get_layout_css() -> str:  # type: ignore[no-redef]
                return ""
        try:
            from .components import get_components_css  # type: ignore
        except Exception:
            def get_components_css() -> str:  # type: ignore[no-redef]
                return ""
        return "\n".join([_safe(get_base_css), _safe(get_layout_css), _safe(get_components_css)])


def get_global_css() -> str:
    """
    Return full CSS string for injection.
    Prefer importing from fum_rt.frontend.styles instead of this legacy module.
    """
    return _get_global_css()


__all__ = ["get_global_css"]]]></content>
    </file>
    <file>
      <path>utilities/fs_utils.py</path>
      <content><![CDATA[import os
import json
from typing import Any, List


def list_runs(root: str) -> List[str]:
    """
    List run directories under root, sorted by mtime desc.
    Mirrors logic from the legacy dashboard for identical behavior.
    """
    if not os.path.exists(root):
        return []
    items = []
    for name in os.listdir(root):
        path = os.path.join(root, name)
        if os.path.isdir(path):
            try:
                mt = os.path.getmtime(path)
            except Exception:
                mt = 0.0
            items.append((mt, path))
    items.sort(key=lambda x: x[0], reverse=True)
    return [p for _, p in items]


def read_json_file(path: str) -> Any:
    try:
        with open(path, "r", encoding="utf-8") as fh:
            return json.load(fh)
    except Exception:
        return None


def write_json_file(path: str, data: Any) -> bool:
    try:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "w", encoding="utf-8") as fh:
            json.dump(data, fh, indent=2)
        return True
    except Exception:
        return False


def _list_files(path: str, exts: List[str] | None, recursive: bool = False) -> List[str]:
    """
    List files under a path, optionally filtered by extensions and recursively.
    Excludes common compressed archive extensions to mirror prior UI behavior.
    Returns relative paths when recursive=True, otherwise basenames.
    """
    if not os.path.isdir(path):
        return []

    found: List[str] = []
    compressed_exts = {".zip", ".gz", ".bz2", ".xz", ".rar", ".7z"}
    try:
        if not recursive:
            return [
                f
                for f in os.listdir(path)
                if (exts is None or any(f.lower().endswith(e) for e in exts))
                and not any(f.lower().endswith(c) for c in compressed_exts)
            ]

        for root, _, files in os.walk(path):
            for f in files:
                if (exts is None or any(f.lower().endswith(e) for e in exts)) and not any(
                    f.lower().endswith(c) for c in compressed_exts
                ):
                    # store relative path from the initial scan path
                    rel_path = os.path.relpath(os.path.join(root, f), path)
                    found.append(rel_path)
        return found
    except Exception:
        return []


def latest_checkpoint(run_dir: str) -> str | None:
    """
    Return the absolute path to the latest checkpoint (.h5 or .npz) in a run directory,
    determined by numeric step parsed from filenames like state_000123.h5/npz.
    """
    try:
        files = []
        for fn in os.listdir(run_dir):
            if fn.startswith("state_") and (fn.endswith(".h5") or fn.endswith(".npz")):
                ext = ".h5" if fn.endswith(".h5") else ".npz"
                step_str = fn[6:-len(ext)]
                try:
                    s = int(step_str)
                    files.append((s, os.path.join(run_dir, fn)))
                except Exception:
                    pass
        if files:
            files.sort(key=lambda x: x[0], reverse=True)
            return files[0][1]
    except Exception:
        return None
    return None]]></content>
    </file>
    <file>
      <path>utilities/pdf_utils.py</path>
      <content><![CDATA[from __future__ import annotations

"""
PDF -> Text utilities (bounded, best-effort, dependency-optional)

Design:
- Try light, pure extraction first (no OCR) using available libs in this order:
  1) PyMuPDF (fitz)
  2) pdfminer.six
  3) PyPDF2
- If those produce too little text, optionally fallback to OCR if pytesseract + pdf2image are available.
- Write result to an output .txt path and return it along with the method used.
- Bounded IO: operate only on the provided file, no recursion. No scans in core/ or maps/.

Returns:
- (out_path, method) when successful, where method in {"pymupdf", "pdfminer", "pypdf2", "ocr"}
- (None, "") if conversion not possible or failed.

Notes:
- OCR requires poppler (for pdf2image) and Tesseract installed; function degrades gracefully if missing.
- Keep memory and compute usage modest; OCR dpi kept moderate (e.g., 200).
"""

import os
from typing import Tuple, Optional


_MIN_TEXT_CHARS = 64  # minimal payload to consider extraction successful


def _write_text(out_path: str, text: str) -> bool:
    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        with open(out_path, "w", encoding="utf-8") as fh:
            fh.write(text)
        return True
    except Exception:
        return False


def _try_pymupdf(pdf_path: str) -> Optional[str]:
    try:
        import fitz  # PyMuPDF
    except Exception:
        return None
    try:
        text_parts = []
        with fitz.open(pdf_path) as doc:
            for page in doc:
                text_parts.append(page.get_text() or "")
        text = "\n".join(text_parts)
        return text
    except Exception:
        return None


def _try_pdfminer(pdf_path: str) -> Optional[str]:
    try:
        from pdfminer.high_level import extract_text
    except Exception:
        return None
    try:
        return extract_text(pdf_path) or ""
    except Exception:
        return None


def _try_pypdf2(pdf_path: str) -> Optional[str]:
    try:
        from PyPDF2 import PdfReader
    except Exception:
        return None
    try:
        reader = PdfReader(pdf_path)
        text_parts = []
        for page in reader.pages:
            try:
                text_parts.append(page.extract_text() or "")
            except Exception:
                continue
        return "\n".join(text_parts)
    except Exception:
        return None


def _try_ocr(pdf_path: str, dpi: int = 200) -> Optional[str]:
    """
    OCR fallback using pdf2image + pytesseract, if both available and system supports them.
    """
    try:
        from pdf2image import convert_from_path
        import pytesseract
    except Exception:
        return None
    try:
        images = convert_from_path(pdf_path, dpi=dpi)
        text_parts = []
        for im in images:
            try:
                text_parts.append(pytesseract.image_to_string(im) or "")
            except Exception:
                continue
        return "\n".join(text_parts)
    except Exception:
        return None


def convert_pdf_to_text_file(pdf_path: str, out_dir: str) -> Tuple[Optional[str], str]:
    """
    Convert a PDF to a UTF-8 .txt file.

    Args:
        pdf_path: absolute or relative path to the .pdf file
        out_dir: directory to write the .txt sidecar into

    Returns:
        (out_txt_path, method) on success; (None, "") on failure
    """
    try:
        base = os.path.splitext(os.path.basename(pdf_path))[0] or "document"
        out_txt = os.path.join(out_dir, f"{base}.txt")
    except Exception:
        return None, ""

    # 1) PyMuPDF
    text = _try_pymupdf(pdf_path)
    if text and len(text.strip()) >= _MIN_TEXT_CHARS:
        return (out_txt, "pymupdf") if _write_text(out_txt, text) else (None, "")

    # 2) pdfminer
    text = _try_pdfminer(pdf_path)
    if text and len(text.strip()) >= _MIN_TEXT_CHARS:
        return (out_txt, "pdfminer") if _write_text(out_txt, text) else (None, "")

    # 3) PyPDF2
    text = _try_pypdf2(pdf_path)
    if text and len(text.strip()) >= _MIN_TEXT_CHARS:
        return (out_txt, "pypdf2") if _write_text(out_txt, text) else (None, "")

    # 4) OCR fallback
    text = _try_ocr(pdf_path, dpi=200)
    if text and len(text.strip()) >= _MIN_TEXT_CHARS:
        return (out_txt, "ocr") if _write_text(out_txt, text) else (None, "")

    return None, ""]]></content>
    </file>
    <file>
      <path>utilities/profiles.py</path>
      <content><![CDATA["""
Profile utilities for FUM Live Dashboard.
Centralizes default profile defaults and assembly helpers to avoid duplication.
"""

from typing import Any, Dict, List


def safe_int(x, default=None):
    try:
        return int(x)
    except Exception:
        return default


def safe_float(x, default=None):
    try:
        return float(x)
    except Exception:
        return default


def bool_from_checklist(val) -> bool:
    """
    Dash checklist returns a list of selected values.
    We treat presence of 'on' as True for single-toggle checklists.
    """
    if isinstance(val, list):
        return "on" in val
    return bool(val)


def checklist_from_bool(b: bool) -> List[str]:
    """Inverse of bool_from_checklist for initial Dash values."""
    return ["on"] if bool(b) else []


def get_default_profile() -> Dict[str, Any]:
    """
    Default profile used by the dashboard UI for initial values.
    Mirrors the legacy dashboard defaults exactly.
    """
    return {
        "neurons": 1000,
        "k": 12,
        "hz": 10,
        "domain": "math_physics",
        "use_time_dynamics": True,
        "sparse_mode": False,
        "threshold": 0.15,
        "lambda_omega": 0.10,
        "candidates": 64,
        "walkers": 256,
        "hops": 3,
        "bundle_size": 3,
        "prune_factor": 0.10,
        "status_interval": 1,
        "viz_every": 0,
        "log_every": 1,
        "speak_auto": True,
        "speak_z": 3.0,
        "speak_hysteresis": 0.5,
        "speak_cooldown_ticks": 10,
        "speak_valence_thresh": 0.55,
        "b1_half_life_ticks": 50,
        "stim_group_size": 8,
        "stim_amp": 0.08,
        "stim_decay": 0.92,
        "stim_max_symbols": 128,
        "checkpoint_every": 60,
        "checkpoint_keep": 5,
        "duration": None,
    }


def assemble_profile(
    neurons,
    k,
    hz,
    domain,
    use_td,
    sparse_mode,
    threshold,
    lambda_omega,
    candidates,
    walkers,
    hops,
    status_interval,
    bundle_size,
    prune_factor,
    stim_group_size,
    stim_amp,
    stim_decay,
    stim_max_symbols,
    speak_auto,
    speak_z,
    speak_hyst,
    speak_cd,
    speak_val,
    b1_hl,
    viz_every,
    log_every,
    checkpoint_every,
    checkpoint_keep,
    duration,
    default_profile: Dict[str, Any],
) -> Dict[str, Any]:
    """
    Build a normalized runtime profile dict from UI inputs with robust typing.
    All conversions mirror the legacy dashboard behavior to avoid surprises.
    """
    return {
        "neurons": int(safe_int(neurons, default_profile["neurons"])),
        "k": int(safe_int(k, default_profile["k"])),
        "hz": int(safe_int(hz, default_profile["hz"])),
        "domain": str(domain or default_profile["domain"]),
        "use_time_dynamics": bool_from_checklist(use_td) if use_td is not None else default_profile["use_time_dynamics"],
        "sparse_mode": bool_from_checklist(sparse_mode) if sparse_mode is not None else default_profile["sparse_mode"],
        "threshold": float(safe_float(threshold, default_profile["threshold"])),
        "lambda_omega": float(safe_float(lambda_omega, default_profile["lambda_omega"])),
        "candidates": int(safe_int(candidates, default_profile["candidates"])),
        "walkers": int(safe_int(walkers, default_profile["walkers"])),
        "hops": int(safe_int(hops, default_profile["hops"])),
        "status_interval": int(safe_int(status_interval, default_profile["status_interval"])),
        "bundle_size": int(safe_int(bundle_size, default_profile["bundle_size"])),
        "prune_factor": float(safe_float(prune_factor, default_profile["prune_factor"])),
        "stim_group_size": int(safe_int(stim_group_size, default_profile["stim_group_size"])),
        "stim_amp": float(safe_float(stim_amp, default_profile["stim_amp"])),
        "stim_decay": float(safe_float(stim_decay, default_profile["stim_decay"])),
        "stim_max_symbols": int(safe_int(stim_max_symbols, default_profile["stim_max_symbols"])),
        "speak_auto": bool_from_checklist(speak_auto) if speak_auto is not None else default_profile["speak_auto"],
        "speak_z": float(safe_float(speak_z, default_profile["speak_z"])),
        "speak_hysteresis": float(safe_float(speak_hyst, default_profile["speak_hysteresis"])),
        "speak_cooldown_ticks": int(safe_int(speak_cd, default_profile["speak_cooldown_ticks"])),
        "speak_valence_thresh": float(safe_float(speak_val, default_profile["speak_valence_thresh"])),
        "b1_half_life_ticks": int(safe_int(b1_hl, default_profile["b1_half_life_ticks"])),
        "viz_every": int(safe_int(viz_every, default_profile["viz_every"])),
        "log_every": int(safe_int(log_every, default_profile["log_every"])),
        "checkpoint_every": int(safe_int(checkpoint_every, default_profile["checkpoint_every"])),
        "checkpoint_keep": int(safe_int(checkpoint_keep, default_profile["checkpoint_keep"])),
        "duration": None if duration in (None, "", "None") else int(safe_int(duration, 0)),
    }]]></content>
    </file>
    <file>
      <path>utilities/tail.py</path>
      <content><![CDATA[import os
import json
from typing import Any, Tuple, List


def _parse_jsonl_line(line: str) -> Any:
    try:
        return json.loads(line)
    except Exception:
        return None


def _env_int(name: str, default: int) -> int:
    try:
        v = int(os.environ.get(name, str(default)))
        return v
    except Exception:
        return default


def tail_jsonl_bytes(path: str, last_size: int) -> Tuple[List[Any], int]:
    """
    Tail a JSONL file by byte offset with bounded IO and parse work.

    Inputs:
    - path: file path to JSONL
    - last_size: previous file size (bytes) to resume from

    Returns:
    - (records, new_size)
      records: list of parsed JSON objects appended since last_size (possibly truncated to most recent window)
      new_size: new file size to store for the next call

    Environment (all optional):
    - FUM_UI_TAIL_CAP_BYTES         (default 1_048_576)  — initial/rotation cap window
    - FUM_UI_TAIL_MAX_DELTA_BYTES   (default 131_072)    — max bytes read per tick even if more appended
    - FUM_UI_TAIL_MAX_LINES         (default 600)        — max lines parsed per tick from the new chunk

    Notes:
    - These bounds are UI-only to avoid lag on very large or fast-growing files; older appended
      records may be skipped when the per-tick delta exceeds caps. Core runtime is unaffected.
    """
    if not os.path.exists(path):
        return [], 0
    try:
        size = os.path.getsize(path)
    except Exception:
        return [], last_size

    cap = _env_int("FUM_UI_TAIL_CAP_BYTES", 1_048_576)
    max_delta = _env_int("FUM_UI_TAIL_MAX_DELTA_BYTES", 131_072)
    max_lines = _env_int("FUM_UI_TAIL_MAX_LINES", 600)

    # Establish start offset
    start = last_size if 0 <= last_size <= size else 0

    # Initial read or file rotation: only read the tail cap window
    if (last_size <= 0 or last_size > size) and size > cap:
        start = max(0, size - cap)

    # Always bound per-tick delta to avoid huge reads when many bytes were appended
    delta = size - start
    if delta <= 0:
        return [], size
    if max_delta > 0 and delta > max_delta:
        start = size - max_delta
        delta = max_delta

    try:
        with open(path, "rb") as f:
            f.seek(start)
            data = f.read(delta)
        text = data.decode("utf-8", errors="ignore")
    except Exception:
        return [], size

    # Split once; then optionally keep only the last K lines to bound JSON parsing work
    lines = text.splitlines()
    if max_lines > 0 and len(lines) > max_lines:
        lines = lines[-max_lines:]

    recs: List[Any] = []
    for s in lines:
        s = s.strip()
        if not s:
            continue
        obj = _parse_jsonl_line(s)
        if obj is not None:
            recs.append(obj)
    return recs, size

def tail_jsonl_bytes_config(path: str, last_size: int, cap: int, max_delta: int, max_lines: int) -> Tuple[List[Any], int]:
    """
    Tail a JSONL file by byte offset using explicit per-call caps (no env vars).

    Args:
        path: JSONL file path
        last_size: previous file size in bytes (seek start)
        cap: initial/rotation cap (bytes)
        max_delta: maximum bytes to read this call
        max_lines: maximum lines to parse from the read chunk

    Returns:
        (records, new_size)
    """
    if not os.path.exists(path):
        return [], 0

    # Sanitize inputs
    try:
        cap = int(cap)
    except Exception:
        cap = 1_048_576
    try:
        max_delta = int(max_delta)
    except Exception:
        max_delta = 131_072
    try:
        max_lines = int(max_lines)
    except Exception:
        max_lines = 600
    cap = max(1024, cap)
    max_delta = max(4096, max_delta)
    max_lines = max(1, max_lines)

    try:
        size = os.path.getsize(path)
    except Exception:
        return [], last_size

    start = last_size if 0 <= last_size <= size else 0

    # Initial read or file rotation: read only tail cap window
    if (last_size <= 0 or last_size > size) and size > cap:
        start = max(0, size - cap)

    delta = size - start
    if delta <= 0:
        return [], size
    if max_delta > 0 and delta > max_delta:
        start = size - max_delta
        delta = max_delta

    try:
        with open(path, "rb") as f:
            f.seek(start)
            data = f.read(delta)
        text = data.decode("utf-8", errors="ignore")
    except Exception:
        return [], size

    lines = text.splitlines()
    if max_lines > 0 and len(lines) > max_lines:
        lines = lines[-max_lines:]

    recs: List[Any] = []
    for s in lines:
        s = s.strip()
        if not s:
            continue
        obj = _parse_jsonl_line(s)
        if obj is not None:
            recs.append(obj)
    return recs, size]]></content>
    </file>
  </files>
</fum_frontend_nblm>
